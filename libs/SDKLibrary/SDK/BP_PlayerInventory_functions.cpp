#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerInventory

#include "Basic.hpp"

#include "BP_PlayerInventory_classes.hpp"
#include "BP_PlayerInventory_parameters.hpp"


namespace SDK
{

// Function BP_PlayerInventory.BP_PlayerInventory_C.AddAllEquipmentQuickSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::AddAllEquipmentQuickSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AddAllEquipmentQuickSlots");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AddAmmoToRangeWeapon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlot                       StartSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Split                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotification                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AddAmmoToRangeWeapon(const struct FS_InvSlot& WeaponSlot, const struct FS_InvSlot& StartSlot, bool Split, bool ShowNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AddAmmoToRangeWeapon");

	Params::BP_PlayerInventory_C_AddAmmoToRangeWeapon Parms{};

	Parms.WeaponSlot = std::move(WeaponSlot);
	Parms.StartSlot = std::move(StartSlot);
	Parms.Split = Split;
	Parms.ShowNotification = ShowNotification;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AddAttachmentFromSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     Attachment_Item_ID                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_WeaponInventory_C*            WeaponInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotifications                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::AddAttachmentFromSlot(const struct FS_InvSlotID& Attachment_Item_ID, class UBP_WeaponInventory_C* WeaponInventory, bool ShowNotifications)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AddAttachmentFromSlot");

	Params::BP_PlayerInventory_C_AddAttachmentFromSlot Parms{};

	Parms.Attachment_Item_ID = std::move(Attachment_Item_ID);
	Parms.WeaponInventory = WeaponInventory;
	Parms.ShowNotifications = ShowNotifications;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AddItemToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlot                       ContainerSlot                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    RemainingItem                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvItem                       InvItem                                                (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AddItemToContainer(const struct FS_InvItem& Item, const struct FS_InvSlot& ContainerSlot, bool* RemainingItem, struct FS_InvItem* InvItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AddItemToContainer");

	Params::BP_PlayerInventory_C_AddItemToContainer Parms{};

	Parms.Item = std::move(Item);
	Parms.ContainerSlot = std::move(ContainerSlot);

	UObject::ProcessEvent(Func, &Parms);

	if (RemainingItem != nullptr)
		*RemainingItem = Parms.RemainingItem;

	if (InvItem != nullptr)
		*InvItem = std::move(Parms.InvItem);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AddNewInvPanel
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Internal                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AddNewInvPanel(class UBP_MasterInventory_C* Param_Inventory, bool Internal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AddNewInvPanel");

	Params::BP_PlayerInventory_C_AddNewInvPanel Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Internal = Internal;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AddQuickSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       EquipmentItem                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AddQuickSlots(const struct FS_InvItem& EquipmentItem, class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AddQuickSlots");

	Params::BP_PlayerInventory_C_AddQuickSlots Parms{};

	Parms.EquipmentItem = std::move(EquipmentItem);
	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AllRepairActorCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_RepairActors>          RepairActors                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::AllRepairActorCheck(TArray<struct FS_RepairActors>& RepairActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AllRepairActorCheck");

	Params::BP_PlayerInventory_C_AllRepairActorCheck Parms{};

	Parms.RepairActors = std::move(RepairActors);

	UObject::ProcessEvent(Func, &Parms);

	RepairActors = std::move(Parms.RepairActors);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ApplyAttachment
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     AttachmentItemID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_WeaponInventory_C*            WeaponInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    SpawnAttachment                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotifications                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ApplyAttachment(const struct FS_InvSlotID& AttachmentItemID, class UBP_WeaponInventory_C* WeaponInventory, bool SpawnAttachment, bool ShowNotifications)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ApplyAttachment");

	Params::BP_PlayerInventory_C_ApplyAttachment Parms{};

	Parms.AttachmentItemID = std::move(AttachmentItemID);
	Parms.WeaponInventory = WeaponInventory;
	Parms.SpawnAttachment = SpawnAttachment;
	Parms.ShowNotifications = ShowNotifications;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttachNewAttachment
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::AttachNewAttachment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttachNewAttachment");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttemptToAddItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    StackSearch                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotifications                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RemainingItem                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvItem                       RemainingInvItem                                       (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlotID                     NewItemSlot                                            (Parm, OutParm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AttemptToAddItem(const struct FS_InvItem& InvItem, bool StackSearch, bool ShowNotifications, bool* RemainingItem, struct FS_InvItem* RemainingInvItem, struct FS_InvSlotID* NewItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttemptToAddItem");

	Params::BP_PlayerInventory_C_AttemptToAddItem Parms{};

	Parms.InvItem = std::move(InvItem);
	Parms.StackSearch = StackSearch;
	Parms.ShowNotifications = ShowNotifications;

	UObject::ProcessEvent(Func, &Parms);

	if (RemainingItem != nullptr)
		*RemainingItem = Parms.RemainingItem;

	if (RemainingInvItem != nullptr)
		*RemainingInvItem = std::move(Parms.RemainingInvItem);

	if (NewItemSlot != nullptr)
		*NewItemSlot = std::move(Parms.NewItemSlot);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttemptToAddItemToSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       Inv_Item_ID                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FDataTableRowHandle              Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AttemptToAddItemToSlot(const struct FS_InvSlot& Inv_Item_ID, const struct FDataTableRowHandle& Item, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttemptToAddItemToSlot");

	Params::BP_PlayerInventory_C_AttemptToAddItemToSlot Parms{};

	Parms.Inv_Item_ID = std::move(Inv_Item_ID);
	Parms.Item = std::move(Item);
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttemptToEquipItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ItemEquipped                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AttemptToEquipItem(const struct FS_InvItem& InvItem, bool* ItemEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttemptToEquipItem");

	Params::BP_PlayerInventory_C_AttemptToEquipItem Parms{};

	Parms.InvItem = std::move(InvItem);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemEquipped != nullptr)
		*ItemEquipped = Parms.ItemEquipped;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttemptToEquipWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ShowNotification                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    WeaponEquipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_WeaponSlots                           ItemWeaponSlot                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AttemptToEquipWeapon(const struct FS_InvItem& InvItem, bool ShowNotification, bool* WeaponEquipped, E_WeaponSlots* ItemWeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttemptToEquipWeapon");

	Params::BP_PlayerInventory_C_AttemptToEquipWeapon Parms{};

	Parms.InvItem = std::move(InvItem);
	Parms.ShowNotification = ShowNotification;

	UObject::ProcessEvent(Func, &Parms);

	if (WeaponEquipped != nullptr)
		*WeaponEquipped = Parms.WeaponEquipped;

	if (ItemWeaponSlot != nullptr)
		*ItemWeaponSlot = Parms.ItemWeaponSlot;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttemptToHoldItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       InvSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ItemHeld                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AttemptToHoldItem(const struct FS_InvSlot& InvSlot, bool* ItemHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttemptToHoldItem");

	Params::BP_PlayerInventory_C_AttemptToHoldItem Parms{};

	Parms.InvSlot = std::move(InvSlot);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemHeld != nullptr)
		*ItemHeld = Parms.ItemHeld;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.AttemptToPickupHold
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ItemHeld                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ItemAdded                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::AttemptToPickupHold(const struct FS_InvItem& InvItem, bool* ItemHeld, bool* ItemAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "AttemptToPickupHold");

	Params::BP_PlayerInventory_C_AttemptToPickupHold Parms{};

	Parms.InvItem = std::move(InvItem);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemHeld != nullptr)
		*ItemHeld = Parms.ItemHeld;

	if (ItemAdded != nullptr)
		*ItemAdded = Parms.ItemAdded;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.BeginPlayInventory
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::BeginPlayInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "BeginPlayInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.BleedDamage
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::BleedDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "BleedDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CancelCraftingQueue
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_CraftingQueue                 CancelQueue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            CraftingInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::CancelCraftingQueue(const struct FS_CraftingQueue& CancelQueue, class UBP_MasterInventory_C* CraftingInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CancelCraftingQueue");

	Params::BP_PlayerInventory_C_CancelCraftingQueue Parms{};

	Parms.CancelQueue = std::move(CancelQueue);
	Parms.CraftingInventory = CraftingInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CancelReload
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::CancelReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CancelReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CanInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::CanInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CanInteract");

	Params::BP_PlayerInventory_C_CanInteract Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ChangeState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CharacterState                        NewState                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ChangeState(E_CharacterState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ChangeState");

	Params::BP_PlayerInventory_C_ChangeState Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CheckFFA
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    FFA_                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::CheckFFA(bool* FFA_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CheckFFA");

	Params::BP_PlayerInventory_C_CheckFFA Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FFA_ != nullptr)
		*FFA_ = Parms.FFA_;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CheckRecipeCost
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Recipe                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RemoveItems                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanCraft                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::CheckRecipeCost(class FName Recipe, int32 Amount, bool RemoveItems, bool* CanCraft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CheckRecipeCost");

	Params::BP_PlayerInventory_C_CheckRecipeCost Parms{};

	Parms.Recipe = Recipe;
	Parms.Amount = Amount;
	Parms.RemoveItems = RemoveItems;

	UObject::ProcessEvent(Func, &Parms);

	if (CanCraft != nullptr)
		*CanCraft = Parms.CanCraft;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClearBleed
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClearBleed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClearBleed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClearContainerQuickSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            InvComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClearContainerQuickSlots(class UBP_MasterInventory_C* InvComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClearContainerQuickSlots");

	Params::BP_PlayerInventory_C_ClearContainerQuickSlots Parms{};

	Parms.InvComponent = InvComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientAddCraftingListing
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_CraftingQueue                 NewQueueListing                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            CraftingInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientAddCraftingListing(const struct FS_CraftingQueue& NewQueueListing, class UBP_MasterInventory_C* CraftingInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientAddCraftingListing");

	Params::BP_PlayerInventory_C_ClientAddCraftingListing Parms{};

	Parms.NewQueueListing = std::move(NewQueueListing);
	Parms.CraftingInventory = CraftingInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientAddQuickSlots
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   AddAmount                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientAddQuickSlots(int32 AddAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientAddQuickSlots");

	Params::BP_PlayerInventory_C_ClientAddQuickSlots Parms{};

	Parms.AddAmount = AddAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientClearCurrentItems
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientClearCurrentItems(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientClearCurrentItems");

	Params::BP_PlayerInventory_C_ClientClearCurrentItems Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientClearQuickSlotItem
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientClearQuickSlotItem(int32 QuickSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientClearQuickSlotItem");

	Params::BP_PlayerInventory_C_ClientClearQuickSlotItem Parms{};

	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientCloseContainerWindow
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientCloseContainerWindow(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientCloseContainerWindow");

	Params::BP_PlayerInventory_C_ClientCloseContainerWindow Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientCloseInventory
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientCloseInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientCloseInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientCloseLockpad
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientCloseLockpad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientCloseLockpad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientCodeResult
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Accepted                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientCodeResult(bool Accepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientCodeResult");

	Params::BP_PlayerInventory_C_ClientCodeResult Parms{};

	Parms.Accepted = Accepted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientCreateNotification
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_NotificationDetails           NotificationDetails                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientCreateNotification(const struct FS_NotificationDetails& NotificationDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientCreateNotification");

	Params::BP_PlayerInventory_C_ClientCreateNotification Parms{};

	Parms.NotificationDetails = std::move(NotificationDetails);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientDisableRespawnScreen
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientDisableRespawnScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientDisableRespawnScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientInteract
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientInteract");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenContainerInv
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ToggleInventory                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               InventorySlots                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::ClientOpenContainerInv(class UBP_MasterInventory_C* Param_Inventory, bool Param_ToggleInventory, TArray<struct FS_InvSlot>& InventorySlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenContainerInv");

	Params::BP_PlayerInventory_C_ClientOpenContainerInv Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Param_ToggleInventory = Param_ToggleInventory;
	Parms.InventorySlots = std::move(InventorySlots);

	UObject::ProcessEvent(Func, &Parms);

	InventorySlots = std::move(Parms.InventorySlots);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenExtCookingMenu
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            CookingInventory                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               Param_Inventory                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// TArray<struct FS_CookingSlot>           CookingSlots                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_PlayerInventory_C::ClientOpenExtCookingMenu(class UBP_MasterInventory_C* CookingInventory, const TArray<struct FS_InvSlot>& Param_Inventory, const TArray<struct FS_CookingSlot>& CookingSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenExtCookingMenu");

	Params::BP_PlayerInventory_C_ClientOpenExtCookingMenu Parms{};

	Parms.CookingInventory = CookingInventory;
	Parms.Param_Inventory = std::move(Param_Inventory);
	Parms.CookingSlots = std::move(CookingSlots);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenExtCraftingMenu
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            MasterInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               Param_Inventory                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// TArray<struct FS_CraftingQueue>         Param_CraftingQueue                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    CraftingBlocked                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientOpenExtCraftingMenu(class UBP_MasterInventory_C* MasterInventory, const TArray<struct FS_InvSlot>& Param_Inventory, const TArray<struct FS_CraftingQueue>& Param_CraftingQueue, bool CraftingBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenExtCraftingMenu");

	Params::BP_PlayerInventory_C_ClientOpenExtCraftingMenu Parms{};

	Parms.MasterInventory = MasterInventory;
	Parms.Param_Inventory = std::move(Param_Inventory);
	Parms.Param_CraftingQueue = std::move(Param_CraftingQueue);
	Parms.CraftingBlocked = CraftingBlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenExtEquipmentInv
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_EquipmentInventory_C*         EquipmentInventory                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               Param_Inventory                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::ClientOpenExtEquipmentInv(class UBP_EquipmentInventory_C* EquipmentInventory, const TArray<struct FS_InvSlot>& Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenExtEquipmentInv");

	Params::BP_PlayerInventory_C_ClientOpenExtEquipmentInv Parms{};

	Parms.EquipmentInventory = EquipmentInventory;
	Parms.Param_Inventory = std::move(Param_Inventory);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenExtInv
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            MasterInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               Param_Inventory                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::ClientOpenExtInv(class UBP_MasterInventory_C* MasterInventory, const TArray<struct FS_InvSlot>& Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenExtInv");

	Params::BP_PlayerInventory_C_ClientOpenExtInv Parms{};

	Parms.MasterInventory = MasterInventory;
	Parms.Param_Inventory = std::move(Param_Inventory);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenLockpad
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SetCode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Lock                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientOpenLockpad(bool SetCode, class AActor* Lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenLockpad");

	Params::BP_PlayerInventory_C_ClientOpenLockpad Parms{};

	Parms.SetCode = SetCode;
	Parms.Lock = Lock;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenVenderMenu
// (Net, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_VenderComponent                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               Param_Inventory                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::ClientOpenVenderMenu(class UBP_MasterInventory_C* Param_VenderComponent, const TArray<struct FS_InvSlot>& Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenVenderMenu");

	Params::BP_PlayerInventory_C_ClientOpenVenderMenu Parms{};

	Parms.Param_VenderComponent = Param_VenderComponent;
	Parms.Param_Inventory = std::move(Param_Inventory);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientOpenWeaponWindow
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_WeaponInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ToggleInventory                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientOpenWeaponWindow(class UBP_WeaponInventory_C* Param_Inventory, bool Param_ToggleInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientOpenWeaponWindow");

	Params::BP_PlayerInventory_C_ClientOpenWeaponWindow Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Param_ToggleInventory = Param_ToggleInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UnPauseCookingSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Pause                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UnPauseCookingSlot(int32 Param_Index, bool Pause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UnPauseCookingSlot");

	Params::BP_PlayerInventory_C_UnPauseCookingSlot Parms{};

	Parms.Param_Index = Param_Index;
	Parms.Pause = Pause;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientPauseAllCookingSlotTimers
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientPauseAllCookingSlotTimers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientPauseAllCookingSlotTimers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientPauseCraftingListing
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientPauseCraftingListing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientPauseCraftingListing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientPlaceNamedBuildPart
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_PlayerInventory_C::ClientPlaceNamedBuildPart(const class FText& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientPlaceNamedBuildPart");

	Params::BP_PlayerInventory_C_ClientPlaceNamedBuildPart Parms{};

	Parms.Param_Name = std::move(Param_Name);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientPlayerInventoryRepawned
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientPlayerInventoryRepawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientPlayerInventoryRepawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientPrimaryAction
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    KeyDown                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientPrimaryAction(bool KeyDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientPrimaryAction");

	Params::BP_PlayerInventory_C_ClientPrimaryAction Parms{};

	Parms.KeyDown = KeyDown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientQuickSlotHighlight
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Highlight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientQuickSlotHighlight(int32 QuickSlotIndex, bool Highlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientQuickSlotHighlight");

	Params::BP_PlayerInventory_C_ClientQuickSlotHighlight Parms{};

	Parms.QuickSlotIndex = QuickSlotIndex;
	Parms.Highlight = Highlight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRefreshCraftingList
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FDataTableRowHandle>      Recipes                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_PlayerInventory_C::ClientRefreshCraftingList(const TArray<struct FDataTableRowHandle>& Recipes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRefreshCraftingList");

	Params::BP_PlayerInventory_C_ClientRefreshCraftingList Parms{};

	Parms.Recipes = std::move(Recipes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRefreshGrids
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientRefreshGrids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRefreshGrids");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientReloadChecks
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientReloadChecks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientReloadChecks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRemoveInventory
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientRemoveInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRemoveInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRemoveInvPanel
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Condition                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientRemoveInvPanel(class UBP_MasterInventory_C* Param_Inventory, bool Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRemoveInvPanel");

	Params::BP_PlayerInventory_C_ClientRemoveInvPanel Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Condition = Condition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRemoveQuickSlots
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   RemoveAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientRemoveQuickSlots(int32 RemoveAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRemoveQuickSlots");

	Params::BP_PlayerInventory_C_ClientRemoveQuickSlots Parms{};

	Parms.RemoveAmount = RemoveAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRespawnPlayer
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Random                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientRespawnPlayer(bool Random)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRespawnPlayer");

	Params::BP_PlayerInventory_C_ClientRespawnPlayer Parms{};

	Parms.Random = Random;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientRestartConvertSlotTimer
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_CookingSlot                   CookingSlot                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientRestartConvertSlotTimer(const struct FS_CookingSlot& CookingSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientRestartConvertSlotTimer");

	Params::BP_PlayerInventory_C_ClientRestartConvertSlotTimer Parms{};

	Parms.CookingSlot = std::move(CookingSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientResumeCookingSlotTimer
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_CookingSlot                   CookingSlot                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientResumeCookingSlotTimer(const struct FS_CookingSlot& CookingSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientResumeCookingSlotTimer");

	Params::BP_PlayerInventory_C_ClientResumeCookingSlotTimer Parms{};

	Parms.CookingSlot = std::move(CookingSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientResumeCraftingListing
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientResumeCraftingListing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientResumeCraftingListing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSecondaryAction
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    KeyDown                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientSecondaryAction(bool KeyDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSecondaryAction");

	Params::BP_PlayerInventory_C_ClientSecondaryAction Parms{};

	Parms.KeyDown = KeyDown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSelfInventoryPanel
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientSelfInventoryPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSelfInventoryPanel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSetControlRotation
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AController*                      Controller                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_PlayerInventory_C::ClientSetControlRotation(class AController* Controller, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSetControlRotation");

	Params::BP_PlayerInventory_C_ClientSetControlRotation Parms{};

	Parms.Controller = Controller;
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSetCookingInventorySlot
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_InvSlot>               NewParam                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::ClientSetCookingInventorySlot(const TArray<struct FS_InvSlot>& NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSetCookingInventorySlot");

	Params::BP_PlayerInventory_C_ClientSetCookingInventorySlot Parms{};

	Parms.NewParam = std::move(NewParam);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSetExtInvDetails
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_ContainerDetails              Details                                                (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientSetExtInvDetails(const struct FS_ContainerDetails& Details, class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSetExtInvDetails");

	Params::BP_PlayerInventory_C_ClientSetExtInvDetails Parms{};

	Parms.Details = std::move(Details);
	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSetIgnoreActor
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Param_IgnoreInteractActor                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientSetIgnoreActor(class AActor* Param_IgnoreInteractActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSetIgnoreActor");

	Params::BP_PlayerInventory_C_ClientSetIgnoreActor Parms{};

	Parms.Param_IgnoreInteractActor = Param_IgnoreInteractActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSetInventoryOpen
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_InventoryOpen                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientSetInventoryOpen(const bool Param_InventoryOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSetInventoryOpen");

	Params::BP_PlayerInventory_C_ClientSetInventoryOpen Parms{};

	Parms.Param_InventoryOpen = Param_InventoryOpen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientSetPlayerName
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Param_PlayerName                                       (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_PlayerInventory_C::ClientSetPlayerName(const class FText& Param_PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientSetPlayerName");

	Params::BP_PlayerInventory_C_ClientSetPlayerName Parms{};

	Parms.Param_PlayerName = std::move(Param_PlayerName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientShowRespawnScreen
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientShowRespawnScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientShowRespawnScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientStartCookingSlotTimer
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_CookingSlot                   CookingSlot                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientStartCookingSlotTimer(const struct FS_CookingSlot& CookingSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientStartCookingSlotTimer");

	Params::BP_PlayerInventory_C_ClientStartCookingSlotTimer Parms{};

	Parms.CookingSlot = std::move(CookingSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientStartCraftingListingTimer
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             CraftingRecipe                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            CraftingInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientStartCraftingListingTimer(class FName CraftingRecipe, class UBP_MasterInventory_C* CraftingInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientStartCraftingListingTimer");

	Params::BP_PlayerInventory_C_ClientStartCraftingListingTimer Parms{};

	Parms.CraftingRecipe = CraftingRecipe;
	Parms.CraftingInventory = CraftingInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateAttachment
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateAttachment(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateAttachment");

	Params::BP_PlayerInventory_C_ClientUpdateAttachment Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateAttachmentItems
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_AttachmentSlot>        Attachments                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UBP_WeaponInventory_C*            WeaponInventory                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateAttachmentItems(const TArray<struct FS_AttachmentSlot>& Attachments, const class UBP_WeaponInventory_C* WeaponInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateAttachmentItems");

	Params::BP_PlayerInventory_C_ClientUpdateAttachmentItems Parms{};

	Parms.Attachments = std::move(Attachments);
	Parms.WeaponInventory = WeaponInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateCookingSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       CookingSlot                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateCookingSlot(const struct FS_InvSlot& CookingSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateCookingSlot");

	Params::BP_PlayerInventory_C_ClientUpdateCookingSlot Parms{};

	Parms.CookingSlot = std::move(CookingSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateCraftingListing
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_CraftingQueue                 ListingQueue                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            CraftingInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateCraftingListing(const struct FS_CraftingQueue& ListingQueue, class UBP_MasterInventory_C* CraftingInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateCraftingListing");

	Params::BP_PlayerInventory_C_ClientUpdateCraftingListing Parms{};

	Parms.ListingQueue = std::move(ListingQueue);
	Parms.CraftingInventory = CraftingInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateEquipmentSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_EquipmentSlot                 EquipmentSlot                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateEquipmentSlot(const struct FS_EquipmentSlot& EquipmentSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateEquipmentSlot");

	Params::BP_PlayerInventory_C_ClientUpdateEquipmentSlot Parms{};

	Parms.EquipmentSlot = std::move(EquipmentSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateInvSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       RootInvSlot                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   HeightSlots                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   WidthSlots                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateInvSlot(const struct FS_InvSlot& RootInvSlot, int32 HeightSlots, int32 WidthSlots, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateInvSlot");

	Params::BP_PlayerInventory_C_ClientUpdateInvSlot Parms{};

	Parms.RootInvSlot = std::move(RootInvSlot);
	Parms.HeightSlots = HeightSlots;
	Parms.WidthSlots = WidthSlots;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateItemSlots
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_InvSlot>               Slots                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FS_ContainerDetails              Param_InventoryDetails                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateItemSlots(const TArray<struct FS_InvSlot>& Slots, const struct FS_ContainerDetails& Param_InventoryDetails, class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateItemSlots");

	Params::BP_PlayerInventory_C_ClientUpdateItemSlots Parms{};

	Parms.Slots = std::move(Slots);
	Parms.Param_InventoryDetails = std::move(Param_InventoryDetails);
	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateQuickSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateQuickSlot(const struct FS_InvSlotID& InvSlotID, int32 QuickSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateQuickSlot");

	Params::BP_PlayerInventory_C_ClientUpdateQuickSlot Parms{};

	Parms.InvSlotID = std::move(InvSlotID);
	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateSlotsWithItems
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_InvSlot>               Slots                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateSlotsWithItems(const TArray<struct FS_InvSlot>& Slots, class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateSlotsWithItems");

	Params::BP_PlayerInventory_C_ClientUpdateSlotsWithItems Parms{};

	Parms.Slots = std::move(Slots);
	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateState
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CharacterState                        CharacterState                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateState(E_CharacterState CharacterState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateState");

	Params::BP_PlayerInventory_C_ClientUpdateState Parms{};

	Parms.CharacterState = CharacterState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateStatUI
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ClientUpdateStatUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateStatUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateWeaponQuickSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  WeaponSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlotID                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateWeaponQuickSlot(const struct FS_WeaponSlotID& WeaponSlotID, int32 QuickSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateWeaponQuickSlot");

	Params::BP_PlayerInventory_C_ClientUpdateWeaponQuickSlot Parms{};

	Parms.WeaponSlotID = std::move(WeaponSlotID);
	Parms.QuickSlotID = QuickSlotID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUpdateWeaponSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlot                    Weapon_Slot                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUpdateWeaponSlot(const struct FS_WeaponSlot& Weapon_Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUpdateWeaponSlot");

	Params::BP_PlayerInventory_C_ClientUpdateWeaponSlot Parms{};

	Parms.Weapon_Slot = std::move(Weapon_Slot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ClientUseQuickSlot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InstantPlacement                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ClientUseQuickSlot(int32 QuickSlotIndex, bool InstantPlacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ClientUseQuickSlot");

	Params::BP_PlayerInventory_C_ClientUseQuickSlot Parms{};

	Parms.QuickSlotIndex = QuickSlotIndex;
	Parms.InstantPlacement = InstantPlacement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CloseCodeLockUI
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::CloseCodeLockUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CloseCodeLockUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CloseInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::CloseInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CloseInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CombineSlotStacks
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       StartSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlot                       EndSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    SplitStack                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_SpecialSlotType                       SpecialType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotifications                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::CombineSlotStacks(const struct FS_InvSlot& StartSlot, const struct FS_InvSlot& EndSlot, bool SplitStack, E_SpecialSlotType SpecialType, bool ShowNotifications)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CombineSlotStacks");

	Params::BP_PlayerInventory_C_CombineSlotStacks Parms{};

	Parms.StartSlot = std::move(StartSlot);
	Parms.EndSlot = std::move(EndSlot);
	Parms.SplitStack = SplitStack;
	Parms.SpecialType = SpecialType;
	Parms.ShowNotifications = ShowNotifications;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ConsumeItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Consumed                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ConsumeItem(const struct FS_InvItem& Item, bool* Consumed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ConsumeItem");

	Params::BP_PlayerInventory_C_ConsumeItem Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	if (Consumed != nullptr)
		*Consumed = Parms.Consumed;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ContextMenu
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_InteractionContextMenu_C*     Param_ContextMenu                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ContextMenu(class UBP_InteractionContextMenu_C** Param_ContextMenu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ContextMenu");

	Params::BP_PlayerInventory_C_ContextMenu Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_ContextMenu != nullptr)
		*Param_ContextMenu = Parms.Param_ContextMenu;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.CreateNotificationInChild
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_NotificationDetails           NotificationDetails                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_PlayerInventory_C::CreateNotificationInChild(const struct FS_NotificationDetails& NotificationDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "CreateNotificationInChild");

	Params::BP_PlayerInventory_C_CreateNotificationInChild Parms{};

	Parms.NotificationDetails = std::move(NotificationDetails);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DecreaseHealth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    PlayTakeDamageSound                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFallDamage_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DecreaseHealth(int32 Amount, bool PlayTakeDamageSound, bool bFallDamage_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DecreaseHealth");

	Params::BP_PlayerInventory_C_DecreaseHealth Parms{};

	Parms.Amount = Amount;
	Parms.PlayTakeDamageSound = PlayTakeDamageSound;
	Parms.bFallDamage_ = bFallDamage_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DecreaseHeldItemDurability
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DecreaseAmount                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DecreaseHeldItemDurability(double DecreaseAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DecreaseHeldItemDurability");

	Params::BP_PlayerInventory_C_DecreaseHeldItemDurability Parms{};

	Parms.DecreaseAmount = DecreaseAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DecreaseHunger
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DecreaseHunger(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DecreaseHunger");

	Params::BP_PlayerInventory_C_DecreaseHunger Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DecreaseStamina
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DecreaseStamina(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DecreaseStamina");

	Params::BP_PlayerInventory_C_DecreaseStamina Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DecreaseThirst
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DecreaseThirst(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DecreaseThirst");

	Params::BP_PlayerInventory_C_DecreaseThirst Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DehydrationState
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DehydrationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DehydrationState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DelayPlace
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DelayPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DelayPlace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DelayPlayMontage
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DelayPlayMontage(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DelayPlayMontage");

	Params::BP_PlayerInventory_C_DelayPlayMontage Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DelaySelfDeactivateDance
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DelaySelfDeactivateDance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DelaySelfDeactivateDance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DestroyCharacterBody
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DestroyCharacterBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DestroyCharacterBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DestroyDeadCharacterBody
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DestroyDeadCharacterBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DestroyDeadCharacterBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DestroyEquipmentItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_EquipmentType                         EquipmentSlot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DestroyEquipmentItem(E_EquipmentType EquipmentSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DestroyEquipmentItem");

	Params::BP_PlayerInventory_C_DestroyEquipmentItem Parms{};

	Parms.EquipmentSlot = EquipmentSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DropBombInput
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DropBombInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DropBombInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DropFlagInput
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::DropFlagInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DropFlagInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.DropItemFromSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     SlotID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_SpecialSlotType                       SpecialType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Split                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::DropItemFromSlot(const struct FS_InvSlotID& SlotID, E_SpecialSlotType SpecialType, bool Split)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "DropItemFromSlot");

	Params::BP_PlayerInventory_C_DropItemFromSlot Parms{};

	Parms.SlotID = std::move(SlotID);
	Parms.SpecialType = SpecialType;
	Parms.Split = Split;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.EndInteraction
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::EndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "EndInteraction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.EquipItemFromSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     SlotID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_EquipmentSlotID               EquipmentSlotID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::EquipItemFromSlot(const struct FS_InvSlotID& SlotID, const struct FS_EquipmentSlotID& EquipmentSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "EquipItemFromSlot");

	Params::BP_PlayerInventory_C_EquipItemFromSlot Parms{};

	Parms.SlotID = std::move(SlotID);
	Parms.EquipmentSlotID = std::move(EquipmentSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.EquipWeaponFromSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     Slot_ID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_WeaponSlotID                  Weapon_Slot_ID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::EquipWeaponFromSlot(const struct FS_InvSlotID& Slot_ID, const struct FS_WeaponSlotID& Weapon_Slot_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "EquipWeaponFromSlot");

	Params::BP_PlayerInventory_C_EquipWeaponFromSlot Parms{};

	Parms.Slot_ID = std::move(Slot_ID);
	Parms.Weapon_Slot_ID = std::move(Weapon_Slot_ID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ExecuteUbergraph_BP_PlayerInventory
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ExecuteUbergraph_BP_PlayerInventory(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ExecuteUbergraph_BP_PlayerInventory");

	Params::BP_PlayerInventory_C_ExecuteUbergraph_BP_PlayerInventory Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.FindAttachmentSlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::FindAttachmentSlot(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "FindAttachmentSlot");

	Params::BP_PlayerInventory_C_FindAttachmentSlot Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.FindCompatiableWeaponSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       WeaponItem                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_WeaponSlots                           Slot                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::FindCompatiableWeaponSlot(const struct FS_InvItem& WeaponItem, E_WeaponSlots* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "FindCompatiableWeaponSlot");

	Params::BP_PlayerInventory_C_FindCompatiableWeaponSlot Parms{};

	Parms.WeaponItem = std::move(WeaponItem);

	UObject::ProcessEvent(Func, &Parms);

	if (Slot != nullptr)
		*Slot = Parms.Slot;

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.FindMontage
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class USkeletalMesh*, class UAnimMontage*>TargetMap                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    AnimFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     Montage                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::FindMontage(const TMap<class USkeletalMesh*, class UAnimMontage*>& TargetMap, bool* AnimFound, class UAnimMontage** Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "FindMontage");

	Params::BP_PlayerInventory_C_FindMontage Parms{};

	Parms.TargetMap = std::move(TargetMap);

	UObject::ProcessEvent(Func, &Parms);

	if (AnimFound != nullptr)
		*AnimFound = Parms.AnimFound;

	if (Montage != nullptr)
		*Montage = Parms.Montage;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.FindQuickSlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_QuickSlot_C*                  OutputSlot                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::FindQuickSlot(int32 QuickSlotIndex, class UBP_QuickSlot_C** OutputSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "FindQuickSlot");

	Params::BP_PlayerInventory_C_FindQuickSlot Parms{};

	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutputSlot != nullptr)
		*OutputSlot = Parms.OutputSlot;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.FindSpawnPoint
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Random                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnLocation                                          (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::FindSpawnPoint(bool Random, struct FTransform* SpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "FindSpawnPoint");

	Params::BP_PlayerInventory_C_FindSpawnPoint Parms{};

	Parms.Random = Random;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnLocation != nullptr)
		*SpawnLocation = std::move(Parms.SpawnLocation);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.HealthRegeneration
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::HealthRegeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "HealthRegeneration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.HitActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AActor*                           Param_HitActor                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              HitComponent                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::HitActor(const struct FHitResult& Hit, class AActor** Param_HitActor, class UPrimitiveComponent** HitComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "HitActor");

	Params::BP_PlayerInventory_C_HitActor Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (Param_HitActor != nullptr)
		*Param_HitActor = Parms.Param_HitActor;

	if (HitComponent != nullptr)
		*HitComponent = Parms.HitComponent;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.HoldingItemCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       InvSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::HoldingItemCheck(const struct FS_InvSlot& InvSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "HoldingItemCheck");

	Params::BP_PlayerInventory_C_HoldingItemCheck Parms{};

	Parms.InvSlot = std::move(InvSlot);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.HoldingWeaponCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlot                    WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::HoldingWeaponCheck(const struct FS_WeaponSlot& WeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "HoldingWeaponCheck");

	Params::BP_PlayerInventory_C_HoldingWeaponCheck Parms{};

	Parms.WeaponSlot = std::move(WeaponSlot);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.HungerState
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::HungerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "HungerState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Param_InAction                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InAction(bool* Param_InAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InAction");

	Params::BP_PlayerInventory_C_InAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_InAction != nullptr)
		*Param_InAction = Parms.Param_InAction;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IncreaseHealth
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::IncreaseHealth(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IncreaseHealth");

	Params::BP_PlayerInventory_C_IncreaseHealth Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IncreaseHunger
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::IncreaseHunger(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IncreaseHunger");

	Params::BP_PlayerInventory_C_IncreaseHunger Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IncreaseStamina
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::IncreaseStamina(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IncreaseStamina");

	Params::BP_PlayerInventory_C_IncreaseStamina Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IncreaseThirst
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::IncreaseThirst(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IncreaseThirst");

	Params::BP_PlayerInventory_C_IncreaseThirst Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InGameLoadComponentData
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_SGKSaveGame_C*                Save                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InGameLoadComponentData(class UBP_SGKSaveGame_C* Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InGameLoadComponentData");

	Params::BP_PlayerInventory_C_InGameLoadComponentData Parms{};

	Parms.Save = Save;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InGameLoadPlayerInventory
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_SGKSaveGame_C*                Save                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InGameLoadPlayerInventory(class UBP_SGKSaveGame_C* Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InGameLoadPlayerInventory");

	Params::BP_PlayerInventory_C_InGameLoadPlayerInventory Parms{};

	Parms.Save = Save;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InitializePlayerInventory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::InitializePlayerInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InitializePlayerInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InpActEvt_Dance_K2Node_InputActionEvent_0
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InpActEvt_Dance_K2Node_InputActionEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InpActEvt_Dance_K2Node_InputActionEvent_0");

	Params::BP_PlayerInventory_C_InpActEvt_Dance_K2Node_InputActionEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InteractionMath
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CameraType                            CameraView                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceDistance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Start                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          End                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InteractionMath(E_CameraType CameraView, double TraceDistance, struct FVector* Start, struct FVector* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InteractionMath");

	Params::BP_PlayerInventory_C_InteractionMath Parms{};

	Parms.CameraView = CameraView;
	Parms.TraceDistance = TraceDistance;

	UObject::ProcessEvent(Func, &Parms);

	if (Start != nullptr)
		*Start = std::move(Parms.Start);

	if (End != nullptr)
		*End = std::move(Parms.End);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InteractTrace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_WorldActions                          ActionType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InteractTrace(const struct FVector& Start, const struct FVector& End, E_WorldActions ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InteractTrace");

	Params::BP_PlayerInventory_C_InteractTrace Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ActionType = ActionType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.InventoryToggled__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Open                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::InventoryToggled__DelegateSignature(bool Open)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "InventoryToggled__DelegateSignature");

	Params::BP_PlayerInventory_C_InventoryToggled__DelegateSignature Parms{};

	Parms.Open = Open;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IsInNoDamageZone
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::IsInNoDamageZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IsInNoDamageZone");

	Params::BP_PlayerInventory_C_IsInNoDamageZone Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IsInPlayerInv
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            InventoryComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsInPlayerInv                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::IsInPlayerInv(class UBP_MasterInventory_C* InventoryComponent, bool* Param_IsInPlayerInv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IsInPlayerInv");

	Params::BP_PlayerInventory_C_IsInPlayerInv Parms{};

	Parms.InventoryComponent = InventoryComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_IsInPlayerInv != nullptr)
		*Param_IsInPlayerInv = Parms.Param_IsInPlayerInv;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IsInventoryEquipped
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            ItemInv                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_EquipmentInventory_C*         EquipmentInv                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    IsEquipped                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::IsInventoryEquipped(class UBP_MasterInventory_C* ItemInv, class UBP_EquipmentInventory_C* EquipmentInv, bool* IsEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IsInventoryEquipped");

	Params::BP_PlayerInventory_C_IsInventoryEquipped Parms{};

	Parms.ItemInv = ItemInv;
	Parms.EquipmentInv = EquipmentInv;

	UObject::ProcessEvent(Func, &Parms);

	if (IsEquipped != nullptr)
		*IsEquipped = Parms.IsEquipped;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.IsItemHeld
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Item_ID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::IsItemHeld(class FName Item_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "IsItemHeld");

	Params::BP_PlayerInventory_C_IsItemHeld Parms{};

	Parms.Item_ID = Item_ID;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ItemActionCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_InventoryActions                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AllowUse                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ItemActionCheck(const struct FS_InvItem& Item, E_InventoryActions Action, bool* AllowUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ItemActionCheck");

	Params::BP_PlayerInventory_C_ItemActionCheck Parms{};

	Parms.Item = std::move(Item);
	Parms.Action = Action;

	UObject::ProcessEvent(Func, &Parms);

	if (AllowUse != nullptr)
		*AllowUse = Parms.AllowUse;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.KnownRecipeCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              RecipeDataHandle                                       (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::KnownRecipeCheck(const struct FDataTableRowHandle& RecipeDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "KnownRecipeCheck");

	Params::BP_PlayerInventory_C_KnownRecipeCheck Parms{};

	Parms.RecipeDataHandle = std::move(RecipeDataHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.LeanCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::LeanCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "LeanCheck");

	Params::BP_PlayerInventory_C_LeanCheck Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.LearnAllItemRecipes
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    RecipeLearnt                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::LearnAllItemRecipes(const struct FS_InvItem& InvItem, bool* RecipeLearnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "LearnAllItemRecipes");

	Params::BP_PlayerInventory_C_LearnAllItemRecipes Parms{};

	Parms.InvItem = std::move(InvItem);

	UObject::ProcessEvent(Func, &Parms);

	if (RecipeLearnt != nullptr)
		*RecipeLearnt = Parms.RecipeLearnt;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.LearnNewRecipe
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              RecipeDataHandle                                       (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::LearnNewRecipe(const struct FDataTableRowHandle& RecipeDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "LearnNewRecipe");

	Params::BP_PlayerInventory_C_LearnNewRecipe Parms{};

	Parms.RecipeDataHandle = std::move(RecipeDataHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.LoadComponentData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_SGKSaveGame_C*                SaveGame                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    LoadComplete                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::LoadComponentData(class UBP_SGKSaveGame_C* SaveGame, bool* LoadComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "LoadComponentData");

	Params::BP_PlayerInventory_C_LoadComponentData Parms{};

	Parms.SaveGame = SaveGame;

	UObject::ProcessEvent(Func, &Parms);

	if (LoadComplete != nullptr)
		*LoadComplete = Parms.LoadComplete;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.LoadPlayerInventory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LoadLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::LoadPlayerInventory(bool LoadLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "LoadPlayerInventory");

	Params::BP_PlayerInventory_C_LoadPlayerInventory Parms{};

	Parms.LoadLocation = LoadLocation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.LookAtTrace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::LookAtTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "LookAtTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MC_DisableCollisions
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::MC_DisableCollisions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MC_DisableCollisions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MoveAddToContainer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       StartSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlot                       EndSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Split                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotification                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::MoveAddToContainer(const struct FS_InvSlot& StartSlot, const struct FS_InvSlot& EndSlot, bool Split, bool ShowNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MoveAddToContainer");

	Params::BP_PlayerInventory_C_MoveAddToContainer Parms{};

	Parms.StartSlot = std::move(StartSlot);
	Parms.EndSlot = std::move(EndSlot);
	Parms.Split = Split;
	Parms.ShowNotification = ShowNotification;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MoveAttachmentAddToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_AttachmentSlotID              Attachment_ID                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlot                       EndSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ChecksOnly                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::MoveAttachmentAddToContainer(const struct FS_AttachmentSlotID& Attachment_ID, const struct FS_InvSlot& EndSlot, bool ChecksOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MoveAttachmentAddToContainer");

	Params::BP_PlayerInventory_C_MoveAttachmentAddToContainer Parms{};

	Parms.Attachment_ID = std::move(Attachment_ID);
	Parms.EndSlot = std::move(EndSlot);
	Parms.ChecksOnly = ChecksOnly;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MoveItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     StartSlotID                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlotID                     EndSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Split                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_SpecialSlotType                       SpecialType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotifications                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ItemMoved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::MoveItem(const struct FS_InvSlotID& StartSlotID, const struct FS_InvSlotID& EndSlotID, bool Rotated, bool Split, E_SpecialSlotType SpecialType, bool ShowNotifications, bool* ItemMoved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MoveItem");

	Params::BP_PlayerInventory_C_MoveItem Parms{};

	Parms.StartSlotID = std::move(StartSlotID);
	Parms.EndSlotID = std::move(EndSlotID);
	Parms.Rotated = Rotated;
	Parms.Split = Split;
	Parms.SpecialType = SpecialType;
	Parms.ShowNotifications = ShowNotifications;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemMoved != nullptr)
		*ItemMoved = Parms.ItemMoved;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MovementInput
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::MovementInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MovementInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MulticastInitPlayerInventory
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::MulticastInitPlayerInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MulticastInitPlayerInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.MulticastPlayFlagDropped
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::MulticastPlayFlagDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "MulticastPlayFlagDropped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OnRep_bVictoryDance
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OnRep_bVictoryDance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OnRep_bVictoryDance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OnRep_CurrentCharacterState
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OnRep_CurrentCharacterState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OnRep_CurrentCharacterState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OnRep_CurrentHealth
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OnRep_CurrentHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OnRep_CurrentHealth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OnRep_CurrentHunger
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OnRep_CurrentHunger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OnRep_CurrentHunger");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OnRep_CurrentStamina
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OnRep_CurrentStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OnRep_CurrentStamina");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OnRep_CurrentThirst
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OnRep_CurrentThirst()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OnRep_CurrentThirst");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenCodeLockUI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SetCode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Lock                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::OpenCodeLockUI(bool SetCode, class AActor* Lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenCodeLockUI");

	Params::BP_PlayerInventory_C_OpenCodeLockUI Parms{};

	Parms.SetCode = SetCode;
	Parms.Lock = Lock;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenEquipmentMenu
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_EquipmentInventory_C*         EquipmentInventory                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::OpenEquipmentMenu(class UBP_EquipmentInventory_C* EquipmentInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenEquipmentMenu");

	Params::BP_PlayerInventory_C_OpenEquipmentMenu Parms{};

	Parms.EquipmentInventory = EquipmentInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenExtCookingMenu
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::OpenExtCookingMenu(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenExtCookingMenu");

	Params::BP_PlayerInventory_C_OpenExtCookingMenu Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenExtCraftingMenu
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::OpenExtCraftingMenu(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenExtCraftingMenu");

	Params::BP_PlayerInventory_C_OpenExtCraftingMenu Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::OpenInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenInvMenu
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::OpenInvMenu(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenInvMenu");

	Params::BP_PlayerInventory_C_OpenInvMenu Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.OpenVenderMenu
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::OpenVenderMenu(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "OpenVenderMenu");

	Params::BP_PlayerInventory_C_OpenVenderMenu Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ParentInventoryCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            AddInventory                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            ContainerInventory                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    AllowAdd                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ParentInventoryCheck(class UBP_MasterInventory_C* AddInventory, class UBP_MasterInventory_C* ContainerInventory, bool* AllowAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ParentInventoryCheck");

	Params::BP_PlayerInventory_C_ParentInventoryCheck Parms{};

	Parms.AddInventory = AddInventory;
	Parms.ContainerInventory = ContainerInventory;

	UObject::ProcessEvent(Func, &Parms);

	if (AllowAdd != nullptr)
		*AllowAdd = Parms.AllowAdd;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayerDied__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APlayerController*                Controller                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayerDied__DelegateSignature(class AActor* Player, class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayerDied__DelegateSignature");

	Params::BP_PlayerInventory_C_PlayerDied__DelegateSignature Parms{};

	Parms.Player = Player;
	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayerFindItemWithUseAmountLeft
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ItemIDs                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ItemFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvSlot                       ItemSlot                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayerFindItemWithUseAmountLeft(TArray<class FName>& ItemIDs, bool* ItemFound, struct FS_InvSlot* ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayerFindItemWithUseAmountLeft");

	Params::BP_PlayerInventory_C_PlayerFindItemWithUseAmountLeft Parms{};

	Parms.ItemIDs = std::move(ItemIDs);

	UObject::ProcessEvent(Func, &Parms);

	ItemIDs = std::move(Parms.ItemIDs);

	if (ItemFound != nullptr)
		*ItemFound = Parms.ItemFound;

	if (ItemSlot != nullptr)
		*ItemSlot = std::move(Parms.ItemSlot);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayerFindKeyItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             KeyCode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayerFindKeyItem(class FName KeyCode, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayerFindKeyItem");

	Params::BP_PlayerInventory_C_PlayerFindKeyItem Parms{};

	Parms.KeyCode = KeyCode;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayerFindNotFullUseAmountItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ItemIDs                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ItemFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvSlot                       ItemSlot                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayerFindNotFullUseAmountItems(TArray<class FName>& ItemIDs, bool* ItemFound, struct FS_InvSlot* ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayerFindNotFullUseAmountItems");

	Params::BP_PlayerInventory_C_PlayerFindNotFullUseAmountItems Parms{};

	Parms.ItemIDs = std::move(ItemIDs);

	UObject::ProcessEvent(Func, &Parms);

	ItemIDs = std::move(Parms.ItemIDs);

	if (ItemFound != nullptr)
		*ItemFound = Parms.ItemFound;

	if (ItemSlot != nullptr)
		*ItemSlot = std::move(Parms.ItemSlot);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayerInventoryFreeSlotCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   FreeSlots                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayerInventoryFreeSlotCount(int32* FreeSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayerInventoryFreeSlotCount");

	Params::BP_PlayerInventory_C_PlayerInventoryFreeSlotCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FreeSlots != nullptr)
		*FreeSlots = Parms.FreeSlots;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayerInventoryTotalItemAmount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   TotalAmount                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayerInventoryTotalItemAmount(const struct FS_InvItem& InvItem, int32* TotalAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayerInventoryTotalItemAmount");

	Params::BP_PlayerInventory_C_PlayerInventoryTotalItemAmount Parms{};

	Parms.InvItem = std::move(InvItem);

	UObject::ProcessEvent(Func, &Parms);

	if (TotalAmount != nullptr)
		*TotalAmount = Parms.TotalAmount;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.PlayItemSound
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Sounds                                SoundType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::PlayItemSound(class FName ItemId, E_Sounds SoundType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "PlayItemSound");

	Params::BP_PlayerInventory_C_PlayItemSound Parms{};

	Parms.ItemId = ItemId;
	Parms.SoundType = SoundType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.QuickMove
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ItemIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::QuickMove(class UBP_MasterInventory_C* Param_Inventory, int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "QuickMove");

	Params::BP_PlayerInventory_C_QuickMove Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.ItemIndex = ItemIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.QuickSlotKeyBind
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FKey                             SlotKey                                                (Parm, OutParm, HasGetValueTypeHash)

void UBP_PlayerInventory_C::QuickSlotKeyBind(int32 QuickSlotIndex, struct FKey* SlotKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "QuickSlotKeyBind");

	Params::BP_PlayerInventory_C_QuickSlotKeyBind Parms{};

	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotKey != nullptr)
		*SlotKey = std::move(Parms.SlotKey);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.QuickSlotUseSelect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InstantPlacement                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::QuickSlotUseSelect(int32 QuickSlotIndex, bool InstantPlacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "QuickSlotUseSelect");

	Params::BP_PlayerInventory_C_QuickSlotUseSelect Parms{};

	Parms.QuickSlotIndex = QuickSlotIndex;
	Parms.InstantPlacement = InstantPlacement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_PlayerInventory_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ReceiveTick");

	Params::BP_PlayerInventory_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RechargeStaminaState
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::RechargeStaminaState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RechargeStaminaState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RemoveAttachment
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_AttachmentSlotID              AttachmentID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    DropItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipChecks                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Swap                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowNotifications                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::RemoveAttachment(const struct FS_AttachmentSlotID& AttachmentID, const struct FS_InvSlotID& InvSlotID, bool DropItem, bool Rotated, bool SkipChecks, bool Swap, bool ShowNotifications)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RemoveAttachment");

	Params::BP_PlayerInventory_C_RemoveAttachment Parms{};

	Parms.AttachmentID = std::move(AttachmentID);
	Parms.InvSlotID = std::move(InvSlotID);
	Parms.DropItem = DropItem;
	Parms.Rotated = Rotated;
	Parms.SkipChecks = SkipChecks;
	Parms.Swap = Swap;
	Parms.ShowNotifications = ShowNotifications;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RemoveBombVisual
// (BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::RemoveBombVisual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RemoveBombVisual");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RemoveItemFromSlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       InvSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    SpecialSlot                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::RemoveItemFromSlot(const struct FS_InvSlot& InvSlot, bool SpecialSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RemoveItemFromSlot");

	Params::BP_PlayerInventory_C_RemoveItemFromSlot Parms{};

	Parms.InvSlot = std::move(InvSlot);
	Parms.SpecialSlot = SpecialSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RemoveQuickSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       EquipmentItem                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::RemoveQuickSlots(const struct FS_InvItem& EquipmentItem, class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RemoveQuickSlots");

	Params::BP_PlayerInventory_C_RemoveQuickSlots Parms{};

	Parms.EquipmentItem = std::move(EquipmentItem);
	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RepairActorCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           RepairActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::RepairActorCheck(class UClass* RepairActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RepairActorCheck");

	Params::BP_PlayerInventory_C_RepairActorCheck Parms{};

	Parms.RepairActor = RepairActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RepairItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvItem                       RepairedInvItem                                        (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::RepairItem(const struct FS_InvItem& InvItem, struct FS_InvItem* RepairedInvItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RepairItem");

	Params::BP_PlayerInventory_C_RepairItem Parms{};

	Parms.InvItem = std::move(InvItem);

	UObject::ProcessEvent(Func, &Parms);

	if (RepairedInvItem != nullptr)
		*RepairedInvItem = std::move(Parms.RepairedInvItem);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RepairItemInSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::RepairItemInSlot(const struct FS_InvSlotID& InvSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RepairItemInSlot");

	Params::BP_PlayerInventory_C_RepairItemInSlot Parms{};

	Parms.InvSlotID = std::move(InvSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ResetStats
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ResetStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ResetStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ReturnStateValue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CharacterState                        CharacterState                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_StatReduction>         Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ReturnStateValue(E_CharacterState CharacterState, TArray<struct FS_StatReduction>& Array, double* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ReturnStateValue");

	Params::BP_PlayerInventory_C_ReturnStateValue Parms{};

	Parms.CharacterState = CharacterState;
	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.RotateMoveWidget__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::RotateMoveWidget__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "RotateMoveWidget__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SaveComponentData
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_SGKSaveGame_C*                SaveGame                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SaveComponentData(class UBP_SGKSaveGame_C* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SaveComponentData");

	Params::BP_PlayerInventory_C_SaveComponentData Parms{};

	Parms.SaveGame = SaveGame;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SearchEnemyTrace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::SearchEnemyTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SearchEnemyTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SearchForWeaponMag
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           Weapon                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    MagFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvSlot                       ItemSlot                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SearchForWeaponMag(class UClass* Weapon, bool* MagFound, struct FS_InvSlot* ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SearchForWeaponMag");

	Params::BP_PlayerInventory_C_SearchForWeaponMag Parms{};

	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);

	if (MagFound != nullptr)
		*MagFound = Parms.MagFound;

	if (ItemSlot != nullptr)
		*ItemSlot = std::move(Parms.ItemSlot);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SearchPlayerInventoryForItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_RemoveItem                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ItemsFound                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvSlot                       InvSlots                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               AllInvSlots                                            (Parm, OutParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::SearchPlayerInventoryForItem(class FName Item, int32 Amount, bool Param_RemoveItem, bool* ItemsFound, struct FS_InvSlot* InvSlots, TArray<struct FS_InvSlot>* AllInvSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SearchPlayerInventoryForItem");

	Params::BP_PlayerInventory_C_SearchPlayerInventoryForItem Parms{};

	Parms.Item = Item;
	Parms.Amount = Amount;
	Parms.Param_RemoveItem = Param_RemoveItem;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemsFound != nullptr)
		*ItemsFound = Parms.ItemsFound;

	if (InvSlots != nullptr)
		*InvSlots = std::move(Parms.InvSlots);

	if (AllInvSlots != nullptr)
		*AllInvSlots = std::move(Parms.AllInvSlots);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SearchPlayerInventoryForMultiItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_RemoveItem                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsForReload_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ItemFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvSlot                       InvSlots                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ForReload_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SearchPlayerInventoryForMultiItems(TArray<class FName>& Item, int32 Amount, bool Param_RemoveItem, bool IsForReload_, bool* ItemFound, struct FS_InvSlot* InvSlots, bool* ForReload_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SearchPlayerInventoryForMultiItems");

	Params::BP_PlayerInventory_C_SearchPlayerInventoryForMultiItems Parms{};

	Parms.Item = std::move(Item);
	Parms.Amount = Amount;
	Parms.Param_RemoveItem = Param_RemoveItem;
	Parms.IsForReload_ = IsForReload_;

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);

	if (ItemFound != nullptr)
		*ItemFound = Parms.ItemFound;

	if (InvSlots != nullptr)
		*InvSlots = std::move(Parms.InvSlots);

	if (ForReload_ != nullptr)
		*ForReload_ = Parms.ForReload_;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SelectedContextEntry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_WorldActions                          ActionType                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SelectedContextEntry(E_WorldActions* ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SelectedContextEntry");

	Params::BP_PlayerInventory_C_SelectedContextEntry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ActionType != nullptr)
		*ActionType = Parms.ActionType;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerAddAllQuickSlots
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerAddAllQuickSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerAddAllQuickSlots");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerAddAttachmentFromSlot
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     AttachmentItemID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_WeaponInventory_C*            WeaponInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerAddAttachmentFromSlot(const struct FS_InvSlotID& AttachmentItemID, class UBP_WeaponInventory_C* WeaponInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerAddAttachmentFromSlot");

	Params::BP_PlayerInventory_C_ServerAddAttachmentFromSlot Parms{};

	Parms.AttachmentItemID = std::move(AttachmentItemID);
	Parms.WeaponInventory = WeaponInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerBuyVenderItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_VendorBuy                     VenderBuyListing                                       (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerBuyVenderItem(const struct FS_VendorBuy& VenderBuyListing, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerBuyVenderItem");

	Params::BP_PlayerInventory_C_ServerBuyVenderItem Parms{};

	Parms.VenderBuyListing = std::move(VenderBuyListing);
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerChamberWeapon
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerChamberWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerChamberWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerCheckCode
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Code                                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerCheckCode(const class FText& Code, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerCheckCode");

	Params::BP_PlayerInventory_C_ServerCheckCode Parms{};

	Parms.Code = std::move(Code);
	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerCreateNewCraftingListing
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            CraftingInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FName                             CraftingRecipeRow                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerCreateNewCraftingListing(class UBP_MasterInventory_C* CraftingInventory, class FName CraftingRecipeRow, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerCreateNewCraftingListing");

	Params::BP_PlayerInventory_C_ServerCreateNewCraftingListing Parms{};

	Parms.CraftingInventory = CraftingInventory;
	Parms.CraftingRecipeRow = CraftingRecipeRow;
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerDestroyAttachment
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerDestroyAttachment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerDestroyAttachment");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerDropItemFromSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     SlotID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_SpecialSlotType                       SpecialType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Split                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerDropItemFromSlot(const struct FS_InvSlotID& SlotID, E_SpecialSlotType SpecialType, bool Split)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerDropItemFromSlot");

	Params::BP_PlayerInventory_C_ServerDropItemFromSlot Parms{};

	Parms.SlotID = std::move(SlotID);
	Parms.SpecialType = SpecialType;
	Parms.Split = Split;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerEmptyTargetInventory
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            StartInventory                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            TargetInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerEmptyTargetInventory(class UBP_MasterInventory_C* StartInventory, class UBP_MasterInventory_C* TargetInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerEmptyTargetInventory");

	Params::BP_PlayerInventory_C_ServerEmptyTargetInventory Parms{};

	Parms.StartInventory = StartInventory;
	Parms.TargetInventory = TargetInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerEndChamber
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     FPMontage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerEndChamber(class UAnimMontage* Montage, class UAnimMontage* FPMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerEndChamber");

	Params::BP_PlayerInventory_C_ServerEndChamber Parms{};

	Parms.Montage = Montage;
	Parms.FPMontage = FPMontage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerEndInteraction
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerEndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerEndInteraction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerEndMontage
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     FPMontage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerEndMontage(class UAnimMontage* Montage, class UAnimMontage* FPMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerEndMontage");

	Params::BP_PlayerInventory_C_ServerEndMontage Parms{};

	Parms.Montage = Montage;
	Parms.FPMontage = FPMontage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerEquipItemFromSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     SlotID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_EquipmentSlotID               EquipmentSlotID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerEquipItemFromSlot(const struct FS_InvSlotID& SlotID, const struct FS_EquipmentSlotID& EquipmentSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerEquipItemFromSlot");

	Params::BP_PlayerInventory_C_ServerEquipItemFromSlot Parms{};

	Parms.SlotID = std::move(SlotID);
	Parms.EquipmentSlotID = std::move(EquipmentSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerEquipWeaponFromSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     Slot_ID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_WeaponSlotID                  Weapon_Slot_ID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerEquipWeaponFromSlot(const struct FS_InvSlotID& Slot_ID, const struct FS_WeaponSlotID& Weapon_Slot_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerEquipWeaponFromSlot");

	Params::BP_PlayerInventory_C_ServerEquipWeaponFromSlot Parms{};

	Parms.Slot_ID = std::move(Slot_ID);
	Parms.Weapon_Slot_ID = std::move(Weapon_Slot_ID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerFinishHoldingNewItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerFinishHoldingNewItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerFinishHoldingNewItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerFinishInGameLoad
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerFinishInGameLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerFinishInGameLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerInteract
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          TraceStart                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceEnd                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_WorldActions                          ActionType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerInteract(const struct FVector& TraceStart, const struct FVector& TraceEnd, E_WorldActions ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerInteract");

	Params::BP_PlayerInventory_C_ServerInteract Parms{};

	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceEnd = std::move(TraceEnd);
	Parms.ActionType = ActionType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerKillPlayerCharacter
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsMelee                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsKnife                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MeleeAnim                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerKillPlayerCharacter(bool IsMelee, bool IsKnife, int32 MeleeAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerKillPlayerCharacter");

	Params::BP_PlayerInventory_C_ServerKillPlayerCharacter Parms{};

	Parms.IsMelee = IsMelee;
	Parms.IsKnife = IsKnife;
	Parms.MeleeAnim = MeleeAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerLoadEquipmentPanels
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerLoadEquipmentPanels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerLoadEquipmentPanels");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerLoadGame
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SlotName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FString                           Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerLoadGame(const class FString& SlotName, const class FString& Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerLoadGame");

	Params::BP_PlayerInventory_C_ServerLoadGame Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.Level = std::move(Level);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerMoveItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     StartSlotID                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlotID                     EndSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Split                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_SpecialSlotType                       SpecialType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerMoveItem(const struct FS_InvSlotID& StartSlotID, const struct FS_InvSlotID& EndSlotID, bool Rotated, bool Split, E_SpecialSlotType SpecialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerMoveItem");

	Params::BP_PlayerInventory_C_ServerMoveItem Parms{};

	Parms.StartSlotID = std::move(StartSlotID);
	Parms.EndSlotID = std::move(EndSlotID);
	Parms.Rotated = Rotated;
	Parms.Split = Split;
	Parms.SpecialType = SpecialType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenContainerWindow
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ToggleInventory                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenContainerWindow(class UBP_MasterInventory_C* Param_Inventory, bool Param_ToggleInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenContainerWindow");

	Params::BP_PlayerInventory_C_ServerOpenContainerWindow Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Param_ToggleInventory = Param_ToggleInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenExtCookingMenu
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            CookingInventory                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenExtCookingMenu(class UBP_MasterInventory_C* CookingInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenExtCookingMenu");

	Params::BP_PlayerInventory_C_ServerOpenExtCookingMenu Parms{};

	Parms.CookingInventory = CookingInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenExtCraftingMenu
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            CraftingInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenExtCraftingMenu(class UBP_MasterInventory_C* CraftingInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenExtCraftingMenu");

	Params::BP_PlayerInventory_C_ServerOpenExtCraftingMenu Parms{};

	Parms.CraftingInventory = CraftingInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenExtEquipmentInv
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_EquipmentInventory_C*         EquipmentInventory                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenExtEquipmentInv(class UBP_EquipmentInventory_C* EquipmentInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenExtEquipmentInv");

	Params::BP_PlayerInventory_C_ServerOpenExtEquipmentInv Parms{};

	Parms.EquipmentInventory = EquipmentInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenExtInv
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Inv                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenExtInv(class UBP_MasterInventory_C* Inv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenExtInv");

	Params::BP_PlayerInventory_C_ServerOpenExtInv Parms{};

	Parms.Inv = Inv;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenItemContainerWindow
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Toggle_Inventory                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenItemContainerWindow(class UBP_MasterInventory_C* Param_Inventory, int32 Param_Index, bool Toggle_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenItemContainerWindow");

	Params::BP_PlayerInventory_C_ServerOpenItemContainerWindow Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Param_Index = Param_Index;
	Parms.Toggle_Inventory = Toggle_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenItemWeaponWindow
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ToggleInventory                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenItemWeaponWindow(class UBP_MasterInventory_C* Param_Inventory, int32 Param_Index, bool Param_ToggleInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenItemWeaponWindow");

	Params::BP_PlayerInventory_C_ServerOpenItemWeaponWindow Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Param_Index = Param_Index;
	Parms.Param_ToggleInventory = Param_ToggleInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenLockpad
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SetCode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Lock                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenLockpad(bool SetCode, class AActor* Lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenLockpad");

	Params::BP_PlayerInventory_C_ServerOpenLockpad Parms{};

	Parms.SetCode = SetCode;
	Parms.Lock = Lock;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenVenderMenu
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            VenderInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenVenderMenu(class UBP_MasterInventory_C* VenderInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenVenderMenu");

	Params::BP_PlayerInventory_C_ServerOpenVenderMenu Parms{};

	Parms.VenderInventory = VenderInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerOpenWeaponWindow
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ToggleInventory                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerOpenWeaponWindow(class UBP_MasterInventory_C* Param_Inventory, bool Param_ToggleInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerOpenWeaponWindow");

	Params::BP_PlayerInventory_C_ServerOpenWeaponWindow Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.Param_ToggleInventory = Param_ToggleInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerPlayerInventoryRespawned
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerPlayerInventoryRespawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerPlayerInventoryRespawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerPlayMontage
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     FPMontage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerPlayMontage(class UAnimMontage* Montage, class UAnimMontage* FPMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerPlayMontage");

	Params::BP_PlayerInventory_C_ServerPlayMontage Parms{};

	Parms.Montage = Montage;
	Parms.FPMontage = FPMontage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerPrimaryAction
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    KeyDown                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerPrimaryAction(bool KeyDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerPrimaryAction");

	Params::BP_PlayerInventory_C_ServerPrimaryAction Parms{};

	Parms.KeyDown = KeyDown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerQuickMoveItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ItemIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerQuickMoveItem(class UBP_MasterInventory_C* Param_Inventory, int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerQuickMoveItem");

	Params::BP_PlayerInventory_C_ServerQuickMoveItem Parms{};

	Parms.Param_Inventory = Param_Inventory;
	Parms.ItemIndex = ItemIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerRemoveAttachment
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerRemoveAttachment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerRemoveAttachment");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerRemoveUsingPlayer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerRemoveUsingPlayer(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerRemoveUsingPlayer");

	Params::BP_PlayerInventory_C_ServerRemoveUsingPlayer Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerRemoveWeaponAttachment
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_AttachmentSlotID              AttachmentID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_InvSlotID                     EndSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    DropItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerRemoveWeaponAttachment(const struct FS_AttachmentSlotID& AttachmentID, const struct FS_InvSlotID& EndSlotID, bool DropItem, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerRemoveWeaponAttachment");

	Params::BP_PlayerInventory_C_ServerRemoveWeaponAttachment Parms{};

	Parms.AttachmentID = std::move(AttachmentID);
	Parms.EndSlotID = std::move(EndSlotID);
	Parms.DropItem = DropItem;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerRepairItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerRepairItem(const struct FS_InvSlotID& InvSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerRepairItem");

	Params::BP_PlayerInventory_C_ServerRepairItem Parms{};

	Parms.InvSlotID = std::move(InvSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerResetRespawn
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerResetRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerResetRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerRespawnPlayer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Random                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerRespawnPlayer(bool Random)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerRespawnPlayer");

	Params::BP_PlayerInventory_C_ServerRespawnPlayer Parms{};

	Parms.Random = Random;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSaveGame
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SlotName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSaveGame(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSaveGame");

	Params::BP_PlayerInventory_C_ServerSaveGame Parms{};

	Parms.SlotName = std::move(SlotName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSecondaryAction
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    KeyDown                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSecondaryAction(bool KeyDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSecondaryAction");

	Params::BP_PlayerInventory_C_ServerSecondaryAction Parms{};

	Parms.KeyDown = KeyDown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSellVenderItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_VendorSell                    VenderSellItem                                         (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSellVenderItem(const struct FS_VendorSell& VenderSellItem, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSellVenderItem");

	Params::BP_PlayerInventory_C_ServerSellVenderItem Parms{};

	Parms.VenderSellItem = std::move(VenderSellItem);
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSetBuildMode
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_BuildMode                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSetBuildMode(bool Param_BuildMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSetBuildMode");

	Params::BP_PlayerInventory_C_ServerSetBuildMode Parms{};

	Parms.Param_BuildMode = Param_BuildMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSetCode
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Code                                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSetCode(const class FText& Code, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSetCode");

	Params::BP_PlayerInventory_C_ServerSetCode Parms{};

	Parms.Code = std::move(Code);
	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSetIgnoreActor
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSetIgnoreActor(class AActor* Actor, double Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSetIgnoreActor");

	Params::BP_PlayerInventory_C_ServerSetIgnoreActor Parms{};

	Parms.Actor = Actor;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSetInventoryOpen
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_InventoryOpen                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSetInventoryOpen(bool Param_InventoryOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSetInventoryOpen");

	Params::BP_PlayerInventory_C_ServerSetInventoryOpen Parms{};

	Parms.Param_InventoryOpen = Param_InventoryOpen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSplitStack
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSplitStack(const struct FS_InvSlotID& InvSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSplitStack");

	Params::BP_PlayerInventory_C_ServerSplitStack Parms{};

	Parms.InvSlotID = std::move(InvSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSprintKey
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Down                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSprintKey(bool Down)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSprintKey");

	Params::BP_PlayerInventory_C_ServerSprintKey Parms{};

	Parms.Down = Down;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSwapAttachmentItems
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_AttachmentSlotID              AttachmentID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_WeaponInventory_C*            WeaponInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSwapAttachmentItems(const struct FS_AttachmentSlotID& AttachmentID, class UBP_WeaponInventory_C* WeaponInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSwapAttachmentItems");

	Params::BP_PlayerInventory_C_ServerSwapAttachmentItems Parms{};

	Parms.AttachmentID = std::move(AttachmentID);
	Parms.WeaponInventory = WeaponInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSwapEquipmentItems
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_EquipmentSlotID               StartEquipmentSlotID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_EquipmentSlotID               EndEquipmentSlotID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSwapEquipmentItems(const struct FS_EquipmentSlotID& StartEquipmentSlotID, const struct FS_EquipmentSlotID& EndEquipmentSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSwapEquipmentItems");

	Params::BP_PlayerInventory_C_ServerSwapEquipmentItems Parms{};

	Parms.StartEquipmentSlotID = std::move(StartEquipmentSlotID);
	Parms.EndEquipmentSlotID = std::move(EndEquipmentSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerSwapWeaponItems
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  StartWeaponSlotID                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_WeaponSlotID                  EndWeaponSlotID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerSwapWeaponItems(const struct FS_WeaponSlotID& StartWeaponSlotID, const struct FS_WeaponSlotID& EndWeaponSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerSwapWeaponItems");

	Params::BP_PlayerInventory_C_ServerSwapWeaponItems Parms{};

	Parms.StartWeaponSlotID = std::move(StartWeaponSlotID);
	Parms.EndWeaponSlotID = std::move(EndWeaponSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerToggleComponentInteractedActor
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerToggleComponentInteractedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerToggleComponentInteractedActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerToggleFireMode
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ServerToggleFireMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerToggleFireMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerToggleMeleeCollision
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    TraceOn                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerToggleMeleeCollision(bool TraceOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerToggleMeleeCollision");

	Params::BP_PlayerInventory_C_ServerToggleMeleeCollision Parms{};

	Parms.TraceOn = TraceOn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUIFinishedCreating
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUIFinishedCreating(class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUIFinishedCreating");

	Params::BP_PlayerInventory_C_ServerUIFinishedCreating Parms{};

	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUnequipItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     EndInvSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_EquipmentSlotID               EquipmentSlotID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    DropItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DestroyItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUnequipItem(const struct FS_InvSlotID& EndInvSlotID, const struct FS_EquipmentSlotID& EquipmentSlotID, bool DropItem, bool Rotated, bool DestroyItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUnequipItem");

	Params::BP_PlayerInventory_C_ServerUnequipItem Parms{};

	Parms.EndInvSlotID = std::move(EndInvSlotID);
	Parms.EquipmentSlotID = std::move(EquipmentSlotID);
	Parms.DropItem = DropItem;
	Parms.Rotated = Rotated;
	Parms.DestroyItem = DestroyItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUnequipWeapon
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     EndInvSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_WeaponSlotID                  WeaponSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    DropItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Destroy                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUnequipWeapon(const struct FS_InvSlotID& EndInvSlotID, const struct FS_WeaponSlotID& WeaponSlotID, bool DropItem, bool Rotated, bool Destroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUnequipWeapon");

	Params::BP_PlayerInventory_C_ServerUnequipWeapon Parms{};

	Parms.EndInvSlotID = std::move(EndInvSlotID);
	Parms.WeaponSlotID = std::move(WeaponSlotID);
	Parms.DropItem = DropItem;
	Parms.Rotated = Rotated;
	Parms.Destroy = Destroy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUpdateClientEquipmentSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_EquipmentType                         EquipmentSlot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUpdateClientEquipmentSlot(E_EquipmentType EquipmentSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUpdateClientEquipmentSlot");

	Params::BP_PlayerInventory_C_ServerUpdateClientEquipmentSlot Parms{};

	Parms.EquipmentSlot = EquipmentSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUpdateClientWeaponSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_WeaponSlots                           WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUpdateClientWeaponSlot(E_WeaponSlots WeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUpdateClientWeaponSlot");

	Params::BP_PlayerInventory_C_ServerUpdateClientWeaponSlot Parms{};

	Parms.WeaponSlot = WeaponSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUpdateItemQuickSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     Slot_ID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUpdateItemQuickSlot(const struct FS_InvSlotID& Slot_ID, int32 QuickSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUpdateItemQuickSlot");

	Params::BP_PlayerInventory_C_ServerUpdateItemQuickSlot Parms{};

	Parms.Slot_ID = std::move(Slot_ID);
	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUpdateRespawnPointName
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_PlayerInventory_C::ServerUpdateRespawnPointName(const class FText& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUpdateRespawnPointName");

	Params::BP_PlayerInventory_C_ServerUpdateRespawnPointName Parms{};

	Parms.Param_Name = std::move(Param_Name);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUpdateState
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CharacterState                        CharacterState                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUpdateState(E_CharacterState CharacterState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUpdateState");

	Params::BP_PlayerInventory_C_ServerUpdateState Parms{};

	Parms.CharacterState = CharacterState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUpdateWeaponQuickSlot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  Weapon_Slot_ID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUpdateWeaponQuickSlot(const struct FS_WeaponSlotID& Weapon_Slot_ID, int32 QuickSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUpdateWeaponQuickSlot");

	Params::BP_PlayerInventory_C_ServerUpdateWeaponQuickSlot Parms{};

	Parms.Weapon_Slot_ID = std::move(Weapon_Slot_ID);
	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUseItemAction
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_InventoryActions                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InstantPlacement                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUseItemAction(const struct FS_InvSlotID& InvSlotID, E_InventoryActions Action, bool InstantPlacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUseItemAction");

	Params::BP_PlayerInventory_C_ServerUseItemAction Parms{};

	Parms.InvSlotID = std::move(InvSlotID);
	Parms.Action = Action;
	Parms.InstantPlacement = InstantPlacement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ServerUseWeaponAction
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  WeaponSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_InventoryActions                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ServerUseWeaponAction(const struct FS_WeaponSlotID& WeaponSlotID, E_InventoryActions Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ServerUseWeaponAction");

	Params::BP_PlayerInventory_C_ServerUseWeaponAction Parms{};

	Parms.WeaponSlotID = std::move(WeaponSlotID);
	Parms.Action = Action;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SetHoldableMulticast
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlot                    Param_HoldingWeaponSlot                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SetHoldableMulticast(const struct FS_WeaponSlot& Param_HoldingWeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SetHoldableMulticast");

	Params::BP_PlayerInventory_C_SetHoldableMulticast Parms{};

	Parms.Param_HoldingWeaponSlot = std::move(Param_HoldingWeaponSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SetHoldableServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlot                    Param_HoldingWeaponSlot                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SetHoldableServer(const struct FS_WeaponSlot& Param_HoldingWeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SetHoldableServer");

	Params::BP_PlayerInventory_C_SetHoldableServer Parms{};

	Parms.Param_HoldingWeaponSlot = std::move(Param_HoldingWeaponSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SetInstigatorServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Param_EnemyInstigator                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SetInstigatorServer(class AActor* Param_EnemyInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SetInstigatorServer");

	Params::BP_PlayerInventory_C_SetInstigatorServer Parms{};

	Parms.Param_EnemyInstigator = Param_EnemyInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SetInvSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       InvSlots                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   Height                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_InvSlot>               UpdatedSlots                                           (Parm, OutParm, ContainsInstancedReference)

void UBP_PlayerInventory_C::SetInvSlots(const struct FS_InvSlot& InvSlots, int32 Height, int32 Width, bool Rotated, TArray<struct FS_InvSlot>* UpdatedSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SetInvSlots");

	Params::BP_PlayerInventory_C_SetInvSlots Parms{};

	Parms.InvSlots = std::move(InvSlots);
	Parms.Height = Height;
	Parms.Width = Width;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);

	if (UpdatedSlots != nullptr)
		*UpdatedSlots = std::move(Parms.UpdatedSlots);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SGK "Fix" default values being lost
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::SGK__Fix__default_values_being_lost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SGK \"Fix\" default values being lost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SGK AllowStartingItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    AllowStartingItems                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SGK_AllowStartingItems(bool* AllowStartingItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SGK AllowStartingItems");

	Params::BP_PlayerInventory_C_SGK_AllowStartingItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllowStartingItems != nullptr)
		*AllowStartingItems = Parms.AllowStartingItems;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SGK ItemSound
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Sounds                                SoundType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SGK_ItemSound(class FName ItemId, E_Sounds SoundType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SGK ItemSound");

	Params::BP_PlayerInventory_C_SGK_ItemSound Parms{};

	Parms.ItemId = ItemId;
	Parms.SoundType = SoundType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SGK RemoveAdditionalChecks
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       InvSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SGK_RemoveAdditionalChecks(const struct FS_InvSlot& InvSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SGK RemoveAdditionalChecks");

	Params::BP_PlayerInventory_C_SGK_RemoveAdditionalChecks Parms{};

	Parms.InvSlot = std::move(InvSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ShowNewAttachment
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ShowNewAttachment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ShowNewAttachment");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SpawnDroppedItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       InvItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SpawnDroppedItem(const struct FS_InvItem& InvItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SpawnDroppedItem");

	Params::BP_PlayerInventory_C_SpawnDroppedItem Parms{};

	Parms.InvItem = std::move(InvItem);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SpawnMainHand
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::SpawnMainHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SpawnMainHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SplitStack
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SplitStack(const struct FS_InvSlotID& InvSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SplitStack");

	Params::BP_PlayerInventory_C_SplitStack Parms{};

	Parms.InvSlotID = std::move(InvSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SprintCheck
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::SprintCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SprintCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.StaminaStateCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CharacterState                        State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Min_Stamina                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanUseState                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::StaminaStateCheck(E_CharacterState State, double Min_Stamina, bool* CanUseState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "StaminaStateCheck");

	Params::BP_PlayerInventory_C_StaminaStateCheck Parms{};

	Parms.State = State;
	Parms.Min_Stamina = Min_Stamina;

	UObject::ProcessEvent(Func, &Parms);

	if (CanUseState != nullptr)
		*CanUseState = Parms.CanUseState;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.StartBleedDamage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   TickDamage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TickTime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  BleedLength                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::StartBleedDamage(int32 TickDamage, double TickTime, double BleedLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "StartBleedDamage");

	Params::BP_PlayerInventory_C_StartBleedDamage Parms{};

	Parms.TickDamage = TickDamage;
	Parms.TickTime = TickTime;
	Parms.BleedLength = BleedLength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.StarvationState
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::StarvationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "StarvationState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.StateTimer
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::StateTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "StateTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SwapAttachments
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_AttachmentSlotID              AttachmentID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_WeaponInventory_C*            WeaponInventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CheckOnly                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerInventory_C::SwapAttachments(const struct FS_AttachmentSlotID& AttachmentID, class UBP_WeaponInventory_C* WeaponInventory, bool CheckOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SwapAttachments");

	Params::BP_PlayerInventory_C_SwapAttachments Parms{};

	Parms.AttachmentID = std::move(AttachmentID);
	Parms.WeaponInventory = WeaponInventory;
	Parms.CheckOnly = CheckOnly;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SwapEquipmentSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_EquipmentSlotID               StartEquipmentSlotID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_EquipmentSlotID               EndEquipmentSlotID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SwapEquipmentSlots(const struct FS_EquipmentSlotID& StartEquipmentSlotID, const struct FS_EquipmentSlotID& EndEquipmentSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SwapEquipmentSlots");

	Params::BP_PlayerInventory_C_SwapEquipmentSlots Parms{};

	Parms.StartEquipmentSlotID = std::move(StartEquipmentSlotID);
	Parms.EndEquipmentSlotID = std::move(EndEquipmentSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.SwapWeaponSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  StartWeaponSlotID                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_WeaponSlotID                  EndWeaponSlotID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::SwapWeaponSlots(const struct FS_WeaponSlotID& StartWeaponSlotID, const struct FS_WeaponSlotID& EndWeaponSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "SwapWeaponSlots");

	Params::BP_PlayerInventory_C_SwapWeaponSlots Parms{};

	Parms.StartWeaponSlotID = std::move(StartWeaponSlotID);
	Parms.EndWeaponSlotID = std::move(EndWeaponSlotID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.TakeDamage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_DamageType                            DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Hitbox                                HitBox                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::TakeDamage(int32 Damage, E_DamageType DamageType, E_Hitbox HitBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "TakeDamage");

	Params::BP_PlayerInventory_C_TakeDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.HitBox = HitBox;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ThirstState
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ThirstState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ThirstState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ToggleBuildPartNameUI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Open                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::ToggleBuildPartNameUI(bool Open)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ToggleBuildPartNameUI");

	Params::BP_PlayerInventory_C_ToggleBuildPartNameUI Parms{};

	Parms.Open = Open;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ToggleCodeLockUI
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ToggleCodeLockUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ToggleCodeLockUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.ToggleInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::ToggleInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "ToggleInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.Tools1Counter
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::Tools1Counter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "Tools1Counter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.Tools2Counter
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::Tools2Counter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "Tools2Counter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UnequipItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     EndSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_EquipmentSlotID               EquipmentSlotID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    DropItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DestroyItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UnequipItem(const struct FS_InvSlotID& EndSlotID, const struct FS_EquipmentSlotID& EquipmentSlotID, bool DropItem, bool Rotated, bool DestroyItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UnequipItem");

	Params::BP_PlayerInventory_C_UnequipItem Parms{};

	Parms.EndSlotID = std::move(EndSlotID);
	Parms.EquipmentSlotID = std::move(EquipmentSlotID);
	Parms.DropItem = DropItem;
	Parms.Rotated = Rotated;
	Parms.DestroyItem = DestroyItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UnequipWeapon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     EndInvSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FS_WeaponSlotID                  WeaponSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    DropItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Destroy                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UnequipWeapon(const struct FS_InvSlotID& EndInvSlotID, const struct FS_WeaponSlotID& WeaponSlotID, bool DropItem, bool Rotated, bool Destroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UnequipWeapon");

	Params::BP_PlayerInventory_C_UnequipWeapon Parms{};

	Parms.EndInvSlotID = std::move(EndInvSlotID);
	Parms.WeaponSlotID = std::move(WeaponSlotID);
	Parms.DropItem = DropItem;
	Parms.Rotated = Rotated;
	Parms.Destroy = Destroy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UnHoldItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UnHoldItem(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UnHoldItem");

	Params::BP_PlayerInventory_C_UnHoldItem Parms{};

	Parms.Force = Force;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateDetails
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_ContainerDetails              Param_InventoryDetails                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class UBP_MasterInventory_C*            Param_Inventory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateDetails(const struct FS_ContainerDetails& Param_InventoryDetails, class UBP_MasterInventory_C* Param_Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateDetails");

	Params::BP_PlayerInventory_C_UpdateDetails Parms{};

	Parms.Param_InventoryDetails = std::move(Param_InventoryDetails);
	Parms.Param_Inventory = Param_Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateEquipmentSlotWidget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_EquipmentSlot                 EquipmentSlot                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateEquipmentSlotWidget(const struct FS_EquipmentSlot& EquipmentSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateEquipmentSlotWidget");

	Params::BP_PlayerInventory_C_UpdateEquipmentSlotWidget Parms{};

	Parms.EquipmentSlot = std::move(EquipmentSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateItemQuickSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     Slot_ID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateItemQuickSlot(const struct FS_InvSlotID& Slot_ID, int32 QuickSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateItemQuickSlot");

	Params::BP_PlayerInventory_C_UpdateItemQuickSlot Parms{};

	Parms.Slot_ID = std::move(Slot_ID);
	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateItemUseAmount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvItem                       Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   Change_Amount                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ItemEmpty                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InvItem                       ItemOut                                                (Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateItemUseAmount(struct FS_InvItem& Item, int32 Change_Amount, bool* ItemEmpty, struct FS_InvItem* ItemOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateItemUseAmount");

	Params::BP_PlayerInventory_C_UpdateItemUseAmount Parms{};

	Parms.Item = std::move(Item);
	Parms.Change_Amount = Change_Amount;

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);

	if (ItemEmpty != nullptr)
		*ItemEmpty = Parms.ItemEmpty;

	if (ItemOut != nullptr)
		*ItemOut = std::move(Parms.ItemOut);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateMaxMovementSpeed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CharacterState                        CharacterState                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateMaxMovementSpeed(E_CharacterState CharacterState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateMaxMovementSpeed");

	Params::BP_PlayerInventory_C_UpdateMaxMovementSpeed Parms{};

	Parms.CharacterState = CharacterState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateQuickSlotItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateQuickSlotItem(const struct FS_InvSlotID& InvSlotID, int32 QuickSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateQuickSlotItem");

	Params::BP_PlayerInventory_C_UpdateQuickSlotItem Parms{};

	Parms.InvSlotID = std::move(InvSlotID);
	Parms.QuickSlot = QuickSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateQuickSlotWeapon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  WeaponSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateQuickSlotWeapon(const struct FS_WeaponSlotID& WeaponSlotID, int32 QuickSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateQuickSlotWeapon");

	Params::BP_PlayerInventory_C_UpdateQuickSlotWeapon Parms{};

	Parms.WeaponSlotID = std::move(WeaponSlotID);
	Parms.QuickSlot = QuickSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateWeaponQuickSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  Weapon_Slot_ID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   QuickSlotIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateWeaponQuickSlot(const struct FS_WeaponSlotID& Weapon_Slot_ID, int32 QuickSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateWeaponQuickSlot");

	Params::BP_PlayerInventory_C_UpdateWeaponQuickSlot Parms{};

	Parms.Weapon_Slot_ID = std::move(Weapon_Slot_ID);
	Parms.QuickSlotIndex = QuickSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UpdateWeaponSlotWidget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlot                    WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UpdateWeaponSlotWidget(const struct FS_WeaponSlot& WeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UpdateWeaponSlotWidget");

	Params::BP_PlayerInventory_C_UpdateWeaponSlotWidget Parms{};

	Parms.WeaponSlot = std::move(WeaponSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UseInventoryAction
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlot                       InvSlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_InventoryActions                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InstantPlacement                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UseInventoryAction(const struct FS_InvSlot& InvSlot, E_InventoryActions Action, bool InstantPlacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UseInventoryAction");

	Params::BP_PlayerInventory_C_UseInventoryAction Parms{};

	Parms.InvSlot = std::move(InvSlot);
	Parms.Action = Action;
	Parms.InstantPlacement = InstantPlacement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UseItemFromSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_InvSlotID                     InvSlotID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_InventoryActions                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InstantPlacement                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UseItemFromSlot(const struct FS_InvSlotID& InvSlotID, E_InventoryActions Action, bool InstantPlacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UseItemFromSlot");

	Params::BP_PlayerInventory_C_UseItemFromSlot Parms{};

	Parms.InvSlotID = std::move(InvSlotID);
	Parms.Action = Action;
	Parms.InstantPlacement = InstantPlacement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UseStaminaState
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerInventory_C::UseStaminaState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UseStaminaState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerInventory.BP_PlayerInventory_C.UseWeaponFromSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_WeaponSlotID                  WeaponSlotID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// E_InventoryActions                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerInventory_C::UseWeaponFromSlot(const struct FS_WeaponSlotID& WeaponSlotID, E_InventoryActions Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerInventory_C", "UseWeaponFromSlot");

	Params::BP_PlayerInventory_C_UseWeaponFromSlot Parms{};

	Parms.WeaponSlotID = std::move(WeaponSlotID);
	Parms.Action = Action;

	UObject::ProcessEvent(Func, &Parms);
}

}

