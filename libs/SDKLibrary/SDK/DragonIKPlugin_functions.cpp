#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "DragonIKPlugin_classes.hpp"
#include "DragonIKPlugin_parameters.hpp"


namespace SDK
{

// Function DragonIKPlugin.DragonIKFootStepsComponent.CallFootSteps
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Foot_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height_difference                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit_info                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDragonIKFootStepsComponent::CallFootSteps(class FName bone_name, const struct FTransform& Foot_transform, float Height_difference, const struct FHitResult& Hit_info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKFootStepsComponent", "CallFootSteps");

	Params::DragonIKFootStepsComponent_CallFootSteps Parms{};

	Parms.bone_name = bone_name;
	Parms.Foot_transform = std::move(Foot_transform);
	Parms.Height_difference = Height_difference;
	Parms.Hit_info = std::move(Hit_info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.CacheSimulationStates
// (Final, Native, Public, BlueprintCallable)

void UDragonIKPhysicsComponent::CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Control_Bone_Handle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Control_Bone_Handle(class FName bone_name, const struct FTransform& Override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.Override_transform = std::move(Override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.FirstTimeInitialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Modify_Reset_Bone_Info
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     bone_list                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.OnHitCallback
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             Optional_Override_Hit_Bone_Name                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_location                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_impulse_direction                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Hit_bone_name                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::OnHitCallback(const struct FHitResult& Hit, class FName Optional_Override_Hit_Bone_Name, struct FVector* Hit_location, struct FVector* Hit_impulse_direction, class FName* Hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "OnHitCallback");

	Params::DragonIKPhysicsComponent_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit_location != nullptr)
		*Hit_location = std::move(Parms.Hit_location);

	if (Hit_impulse_direction != nullptr)
		*Hit_impulse_direction = std::move(Parms.Hit_impulse_direction);

	if (Hit_bone_name != nullptr)
		*Hit_bone_name = Parms.Hit_bone_name;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.PerformActiveRagdoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::PerformActiveRagdoll(float Pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_PerformActiveRagdoll Parms{};

	Parms.Pelvis_mass_override = Pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.ReGrabAllHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::ReGrabAllHandles(bool Exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_ReGrabAllHandles Parms{};

	Parms.Exit_ragdoll = Exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.ReleaseAllHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::ReleaseAllHandles(bool Go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_ReleaseAllHandles Parms{};

	Parms.Go_ragdoll = Go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.SetInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::SetInterpolation(int32 Inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "SetInterpolation");

	Params::DragonIKPhysicsComponent_SetInterpolation Parms{};

	Parms.Inter_value = Inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.UpdatePhysanimData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Attach_Hand_Only
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Attach_Hand_Only(class FName Hand_bone, bool Arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Attach_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Arm_position_recalibrate = Arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.FirstTimeInitialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Freeze_Elbows_Function
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Freeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Grab_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Weapon_mesh_input                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Grab_Weapon(class UPrimitiveComponent* Weapon_mesh_input, class FName Grabbed_bone, bool Simulate_physics, bool Use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Grab_Weapon Parms{};

	Parms.Weapon_mesh_input = Weapon_mesh_input;
	Parms.Grabbed_bone = Grabbed_bone;
	Parms.Simulate_physics = Simulate_physics;
	Parms.Use_gravity = Use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Only
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Hand_Only(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Release_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Plus_Override
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Hand_Plus_Override(class FName Hand_bone, const struct FTransform& Hand_transform, bool Override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Hand_transform = std::move(Hand_transform);
	Parms.Override_hand_location = Override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Weapon(bool Should_simulatephysics, bool Use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Release_Weapon Parms{};

	Parms.Should_simulatephysics = Should_simulatephysics;
	Parms.Use_gravity = Use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Unfreeze_Elbows_Function
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Unfreeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Weapon_Transform_Override
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIK_Library.CustomLookRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          LookAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::CustomLookRotation(const struct FVector& LookAt, const struct FVector& UpDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "CustomLookRotation");

	Params::DragonIK_Library_CustomLookRotation Parms{};

	Parms.LookAt = std::move(LookAt);
	Parms.UpDirection = std::move(UpDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.LookAtRotation_V3
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::LookAtRotation_V3(const struct FVector& Source, const struct FVector& Target, const struct FVector& UpVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "LookAtRotation_V3");

	Params::DragonIK_Library_LookAtRotation_V3 Parms{};

	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);
	Parms.UpVector = std::move(UpVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.LookAtVector_V2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Source_Location                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::LookAtVector_V2(const struct FVector& Source_Location, const struct FVector& LookAt, const struct FVector& UpDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "LookAtVector_V2");

	Params::DragonIK_Library_LookAtVector_V2 Parms{};

	Parms.Source_Location = std::move(Source_Location);
	Parms.LookAt = std::move(LookAt);
	Parms.UpDirection = std::move(UpDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.QuatLookXatLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       LookAtFromTransform                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookAtTarget                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDragonIK_Library::QuatLookXatLocation(const struct FTransform& LookAtFromTransform, const struct FVector& LookAtTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "QuatLookXatLocation");

	Params::DragonIK_Library_QuatLookXatLocation Parms{};

	Parms.LookAtFromTransform = std::move(LookAtFromTransform);
	Parms.LookAtTarget = std::move(LookAtTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

