#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BFL_Actor

#include "Basic.hpp"

#include "BFL_Actor_classes.hpp"
#include "BFL_Actor_parameters.hpp"


namespace SDK
{

// Function BFL_Actor.BFL_Actor_C.StopHitStop
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::StopHitStop(class AActor* Target, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "StopHitStop");

	Params::BFL_Actor_C_StopHitStop Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BFL_Actor.BFL_Actor_C.StartHitStop
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::StartHitStop(class AActor* Actor, double Duration, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "StartHitStop");

	Params::BFL_Actor_C_StartHitStop Parms{};

	Parms.Actor = Actor;
	Parms.Duration = Duration;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BFL_Actor.BFL_Actor_C.SetActorTransformToNewTransform
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LocationTolerance                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBFL_Actor_C::SetActorTransformToNewTransform(class AActor* TargetActor, double InterpSpeed, const struct FTransform& Transform, float LocationTolerance, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "SetActorTransformToNewTransform");

	Params::BFL_Actor_C_SetActorTransformToNewTransform Parms{};

	Parms.TargetActor = TargetActor;
	Parms.InterpSpeed = InterpSpeed;
	Parms.Transform = std::move(Transform);
	Parms.LocationTolerance = LocationTolerance;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BFL_Actor.BFL_Actor_C.SetActorTransformToNewActorLocation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Target_componet                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBFL_Actor_C::SetActorTransformToNewActorLocation(class USceneComponent* Target_componet, class AActor* TargetActor, double InterpSpeed, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "SetActorTransformToNewActorLocation");

	Params::BFL_Actor_C_SetActorTransformToNewActorLocation Parms{};

	Parms.Target_componet = Target_componet;
	Parms.TargetActor = TargetActor;
	Parms.InterpSpeed = InterpSpeed;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BFL_Actor.BFL_Actor_C.RandomColor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FColor                           Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::RandomColor(class UObject* __WorldContext, struct FColor* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "RandomColor");

	Params::BFL_Actor_C_RandomColor Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function BFL_Actor.BFL_Actor_C.IsRightOfActor?
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsOnRightSide_                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::IsRightOfActor_(class AActor* Actor, class AActor* OtherActor, class UObject* __WorldContext, bool* IsOnRightSide_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "IsRightOfActor?");

	Params::BFL_Actor_C_IsRightOfActor_ Parms{};

	Parms.Actor = Actor;
	Parms.OtherActor = OtherActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsOnRightSide_ != nullptr)
		*IsOnRightSide_ = Parms.IsOnRightSide_;
}


// Function BFL_Actor.BFL_Actor_C.IsInFrontOfActor?
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  AcceptanceAngle                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXY_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsInfront_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::IsInFrontOfActor_(class AActor* Actor, class AActor* OtherActor, double AcceptanceAngle, bool UseXY_, bool Debug, class UObject* __WorldContext, bool* IsInfront_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "IsInFrontOfActor?");

	Params::BFL_Actor_C_IsInFrontOfActor_ Parms{};

	Parms.Actor = Actor;
	Parms.OtherActor = OtherActor;
	Parms.AcceptanceAngle = AcceptanceAngle;
	Parms.UseXY_ = UseXY_;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsInfront_ != nullptr)
		*IsInfront_ = Parms.IsInfront_;
}


// Function BFL_Actor.BFL_Actor_C.GetSpeed
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          VelocityThisFrame                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          VelocityLastFrame                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Speed                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetSpeed(const struct FVector& VelocityThisFrame, const struct FVector& VelocityLastFrame, double DeltaTime, class UObject* __WorldContext, double* Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetSpeed");

	Params::BFL_Actor_C_GetSpeed Parms{};

	Parms.VelocityThisFrame = std::move(VelocityThisFrame);
	Parms.VelocityLastFrame = std::move(VelocityLastFrame);
	Parms.DeltaTime = DeltaTime;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Speed != nullptr)
		*Speed = Parms.Speed;
}


// Function BFL_Actor.BFL_Actor_C.GetRandomPointOnSphere
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CirclePoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetRandomPointOnSphere(const struct FVector& Origin, double Radius, bool Debug, class UObject* __WorldContext, struct FVector* CirclePoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetRandomPointOnSphere");

	Params::BFL_Actor_C_GetRandomPointOnSphere Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CirclePoint != nullptr)
		*CirclePoint = std::move(Parms.CirclePoint);
}


// Function BFL_Actor.BFL_Actor_C.GetRandomPointOnCircle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          YAxis                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ZAxis                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CirclePoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetRandomPointOnCircle(const struct FVector& Origin, double Radius, bool Debug, const struct FVector& YAxis, const struct FVector& ZAxis, class UObject* __WorldContext, struct FVector* CirclePoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetRandomPointOnCircle");

	Params::BFL_Actor_C_GetRandomPointOnCircle Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.Debug = Debug;
	Parms.YAxis = std::move(YAxis);
	Parms.ZAxis = std::move(ZAxis);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CirclePoint != nullptr)
		*CirclePoint = std::move(Parms.CirclePoint);
}


// Function BFL_Actor.BFL_Actor_C.GetFurthestInstance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ActorArray                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXY_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Squared_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           FurthestActor                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetFurthestInstance(TArray<class AActor*>& ActorArray, const struct FVector& Origin, bool UseXY_, bool Squared_, bool Debug, class UObject* __WorldContext, class AActor** FurthestActor, double* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetFurthestInstance");

	Params::BFL_Actor_C_GetFurthestInstance Parms{};

	Parms.ActorArray = std::move(ActorArray);
	Parms.Origin = std::move(Origin);
	Parms.UseXY_ = UseXY_;
	Parms.Squared_ = Squared_;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	ActorArray = std::move(Parms.ActorArray);

	if (FurthestActor != nullptr)
		*FurthestActor = Parms.FurthestActor;

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function BFL_Actor.BFL_Actor_C.GetFurthestActorOfClass
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           ActorClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXY_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Squared_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           FurthestActor                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetFurthestActorOfClass(class UClass* ActorClass, const struct FVector& Origin, bool UseXY_, bool Squared_, bool Debug, class UObject* __WorldContext, class AActor** FurthestActor, double* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetFurthestActorOfClass");

	Params::BFL_Actor_C_GetFurthestActorOfClass Parms{};

	Parms.ActorClass = ActorClass;
	Parms.Origin = std::move(Origin);
	Parms.UseXY_ = UseXY_;
	Parms.Squared_ = Squared_;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (FurthestActor != nullptr)
		*FurthestActor = Parms.FurthestActor;

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function BFL_Actor.BFL_Actor_C.GetDistanceToPoint
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Source                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXY_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DistanceSquared_                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DebugDrawDuration                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetDistanceToPoint(const struct FVector& Source, const struct FVector& Target, bool UseXY_, bool DistanceSquared_, bool Debug, double DebugDrawDuration, class UObject* __WorldContext, double* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetDistanceToPoint");

	Params::BFL_Actor_C_GetDistanceToPoint Parms{};

	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);
	Parms.UseXY_ = UseXY_;
	Parms.DistanceSquared_ = DistanceSquared_;
	Parms.Debug = Debug;
	Parms.DebugDrawDuration = DebugDrawDuration;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function BFL_Actor.BFL_Actor_C.GetClosestInstance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ActorArray                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXY_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Squared_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ClosestActor                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetClosestInstance(TArray<class AActor*>& ActorArray, const struct FVector& Origin, bool UseXY_, bool Squared_, bool Debug, class UObject* __WorldContext, class AActor** ClosestActor, double* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetClosestInstance");

	Params::BFL_Actor_C_GetClosestInstance Parms{};

	Parms.ActorArray = std::move(ActorArray);
	Parms.Origin = std::move(Origin);
	Parms.UseXY_ = UseXY_;
	Parms.Squared_ = Squared_;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	ActorArray = std::move(Parms.ActorArray);

	if (ClosestActor != nullptr)
		*ClosestActor = Parms.ClosestActor;

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function BFL_Actor.BFL_Actor_C.GetClosestActorOfClass
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           ActorClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXY_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Squared_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ClosestActor                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetClosestActorOfClass(class UClass* ActorClass, const struct FVector& Origin, bool UseXY_, bool Squared_, bool Debug, class UObject* __WorldContext, class AActor** ClosestActor, double* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetClosestActorOfClass");

	Params::BFL_Actor_C_GetClosestActorOfClass Parms{};

	Parms.ActorClass = ActorClass;
	Parms.Origin = std::move(Origin);
	Parms.UseXY_ = UseXY_;
	Parms.Squared_ = Squared_;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClosestActor != nullptr)
		*ClosestActor = Parms.ClosestActor;

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function BFL_Actor.BFL_Actor_C.GetAngleBetweenActors
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Degrees                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Angle                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::GetAngleBetweenActors(class AActor* Actor, class AActor* OtherActor, bool Degrees, bool Debug, class UObject* __WorldContext, double* Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "GetAngleBetweenActors");

	Params::BFL_Actor_C_GetAngleBetweenActors Parms{};

	Parms.Actor = Actor;
	Parms.OtherActor = OtherActor;
	Parms.Degrees = Degrees;
	Parms.Debug = Debug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Angle != nullptr)
		*Angle = Parms.Angle;
}


// Function BFL_Actor.BFL_Actor_C.CheckInFront
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Source                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          SourceForward                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowDebug                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsInfront_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::CheckInFront(const struct FVector& Source, const struct FVector& SourceForward, const struct FVector& Target, bool ShowDebug, double MaxAngle, class UObject* __WorldContext, bool* IsInfront_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "CheckInFront");

	Params::BFL_Actor_C_CheckInFront Parms{};

	Parms.Source = std::move(Source);
	Parms.SourceForward = std::move(SourceForward);
	Parms.Target = std::move(Target);
	Parms.ShowDebug = ShowDebug;
	Parms.MaxAngle = MaxAngle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsInfront_ != nullptr)
		*IsInfront_ = Parms.IsInfront_;
}


// Function BFL_Actor.BFL_Actor_C.CanSeeActor?
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          EyeLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsToIgnore                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    CanSee_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::CanSeeActor_(const struct FVector& EyeLocation, class AActor* Target, TArray<class AActor*>& ActorsToIgnore, class UObject* __WorldContext, bool* CanSee_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "CanSeeActor?");

	Params::BFL_Actor_C_CanSeeActor_ Parms{};

	Parms.EyeLocation = std::move(EyeLocation);
	Parms.Target = Target;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	ActorsToIgnore = std::move(Parms.ActorsToIgnore);

	if (CanSee_ != nullptr)
		*CanSee_ = Parms.CanSee_;
}


// Function BFL_Actor.BFL_Actor_C.AddToAngle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  NewDegrees                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Degrees_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  NewAngle                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBFL_Actor_C::AddToAngle(double Angle, double NewDegrees, bool Degrees_, class UObject* __WorldContext, double* NewAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_Actor_C", "AddToAngle");

	Params::BFL_Actor_C_AddToAngle Parms{};

	Parms.Angle = Angle;
	Parms.NewDegrees = NewDegrees;
	Parms.Degrees_ = Degrees_;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewAngle != nullptr)
		*NewAngle = Parms.NewAngle;
}

}

