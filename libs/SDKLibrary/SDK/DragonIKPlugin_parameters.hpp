#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function DragonIKPlugin.DragonIKFootStepsComponent.CallFootSteps
// 0x0160 (0x0160 - 0x0000)
struct DragonIKFootStepsComponent_CallFootSteps final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E4[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Foot_transform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height_difference;                                 // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E5[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit_info;                                          // 0x0078(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKFootStepsComponent_CallFootSteps) == 0x000010, "Wrong alignment on DragonIKFootStepsComponent_CallFootSteps");
static_assert(sizeof(DragonIKFootStepsComponent_CallFootSteps) == 0x000160, "Wrong size on DragonIKFootStepsComponent_CallFootSteps");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, bone_name) == 0x000000, "Member 'DragonIKFootStepsComponent_CallFootSteps::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, Foot_transform) == 0x000010, "Member 'DragonIKFootStepsComponent_CallFootSteps::Foot_transform' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, Height_difference) == 0x000070, "Member 'DragonIKFootStepsComponent_CallFootSteps::Height_difference' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, Hit_info) == 0x000078, "Member 'DragonIKFootStepsComponent_CallFootSteps::Hit_info' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Control_Bone_Handle
// 0x0080 (0x0080 - 0x0000)
struct DragonIKPhysicsComponent_Control_Bone_Handle final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F0[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Override_transform;                                // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F1[0xF];                                     // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Control_Bone_Handle) == 0x000010, "Wrong alignment on DragonIKPhysicsComponent_Control_Bone_Handle");
static_assert(sizeof(DragonIKPhysicsComponent_Control_Bone_Handle) == 0x000080, "Wrong size on DragonIKPhysicsComponent_Control_Bone_Handle");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, bone_name) == 0x000000, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, Override_transform) == 0x000010, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::Override_transform' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, Enable) == 0x000070, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::Enable' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKPhysicsComponent_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 Skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_FirstTimeInitialization");
static_assert(sizeof(DragonIKPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKPhysicsComponent_FirstTimeInitialization");
static_assert(offsetof(DragonIKPhysicsComponent_FirstTimeInitialization, Skeleton_input) == 0x000000, "Member 'DragonIKPhysicsComponent_FirstTimeInitialization::Skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Modify_Reset_Bone_Info
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Modify_Reset_Bone_Info final
{
public:
	TArray<class FName>                           bone_list;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Modify_Reset_Bone_Info");
static_assert(sizeof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Modify_Reset_Bone_Info");
static_assert(offsetof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info, bone_list) == 0x000000, "Member 'DragonIKPhysicsComponent_Modify_Reset_Bone_Info::bone_list' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.OnHitCallback
// 0x0128 (0x0128 - 0x0000)
struct DragonIKPhysicsComponent_OnHitCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Optional_Override_Hit_Bone_Name;                   // 0x00E8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Hit_location;                                      // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Hit_impulse_direction;                             // 0x0108(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Hit_bone_name;                                     // 0x0120(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_OnHitCallback) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_OnHitCallback");
static_assert(sizeof(DragonIKPhysicsComponent_OnHitCallback) == 0x000128, "Wrong size on DragonIKPhysicsComponent_OnHitCallback");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Hit) == 0x000000, "Member 'DragonIKPhysicsComponent_OnHitCallback::Hit' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Optional_Override_Hit_Bone_Name) == 0x0000E8, "Member 'DragonIKPhysicsComponent_OnHitCallback::Optional_Override_Hit_Bone_Name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Hit_location) == 0x0000F0, "Member 'DragonIKPhysicsComponent_OnHitCallback::Hit_location' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Hit_impulse_direction) == 0x000108, "Member 'DragonIKPhysicsComponent_OnHitCallback::Hit_impulse_direction' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Hit_bone_name) == 0x000120, "Member 'DragonIKPhysicsComponent_OnHitCallback::Hit_bone_name' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.PerformActiveRagdoll
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_PerformActiveRagdoll final
{
public:
	float                                         Pelvis_mass_override;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_PerformActiveRagdoll) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_PerformActiveRagdoll");
static_assert(sizeof(DragonIKPhysicsComponent_PerformActiveRagdoll) == 0x000004, "Wrong size on DragonIKPhysicsComponent_PerformActiveRagdoll");
static_assert(offsetof(DragonIKPhysicsComponent_PerformActiveRagdoll, Pelvis_mass_override) == 0x000000, "Member 'DragonIKPhysicsComponent_PerformActiveRagdoll::Pelvis_mass_override' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.ReGrabAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_ReGrabAllHandles final
{
public:
	bool                                          Exit_ragdoll;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_ReGrabAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_ReGrabAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_ReGrabAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_ReGrabAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_ReGrabAllHandles, Exit_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_ReGrabAllHandles::Exit_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.ReleaseAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_ReleaseAllHandles final
{
public:
	bool                                          Go_ragdoll;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_ReleaseAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_ReleaseAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_ReleaseAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_ReleaseAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_ReleaseAllHandles, Go_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_ReleaseAllHandles::Go_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.SetInterpolation
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_SetInterpolation final
{
public:
	int32                                         Inter_value;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_SetInterpolation) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_SetInterpolation");
static_assert(sizeof(DragonIKPhysicsComponent_SetInterpolation) == 0x000004, "Wrong size on DragonIKPhysicsComponent_SetInterpolation");
static_assert(offsetof(DragonIKPhysicsComponent_SetInterpolation, Inter_value) == 0x000000, "Member 'DragonIKPhysicsComponent_SetInterpolation::Inter_value' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.UpdatePhysanimData
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_UpdatePhysanimData final
{
public:
	int32                                         LinearStrength;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinearDamp;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularDamp;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_UpdatePhysanimData) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_UpdatePhysanimData");
static_assert(sizeof(DragonIKPhysicsComponent_UpdatePhysanimData) == 0x000010, "Wrong size on DragonIKPhysicsComponent_UpdatePhysanimData");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, LinearStrength) == 0x000000, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::LinearStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, AngularStrength) == 0x000004, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::AngularStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, LinearDamp) == 0x000008, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::LinearDamp' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, AngularDamp) == 0x00000C, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::AngularDamp' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Attach_Hand_Only
// 0x000C (0x000C - 0x0000)
struct DragonIKWeaponPhysicsComponent_Attach_Hand_Only final
{
public:
	class FName                                   Hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Arm_position_recalibrate;                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Attach_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only) == 0x00000C, "Wrong size on DragonIKWeaponPhysicsComponent_Attach_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only, Hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Attach_Hand_Only::Hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Attach_Hand_Only, Arm_position_recalibrate) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Attach_Hand_Only::Arm_position_recalibrate' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 Skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_FirstTimeInitialization");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_FirstTimeInitialization");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_FirstTimeInitialization, Skeleton_input) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_FirstTimeInitialization::Skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Freeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function final
{
public:
	class FName                                   Hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function, Hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function::Hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Grab_Weapon
// 0x0018 (0x0018 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Grab_Weapon final
{
public:
	class UPrimitiveComponent*                    Weapon_mesh_input;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Grabbed_bone;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Simulate_physics;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_gravity;                                       // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F6[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Grab_Weapon) == 0x000008, "Wrong alignment on DragonIKWeaponPhysicsComponent_Grab_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Grab_Weapon) == 0x000018, "Wrong size on DragonIKWeaponPhysicsComponent_Grab_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, Weapon_mesh_input) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::Weapon_mesh_input' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, Grabbed_bone) == 0x000008, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::Grabbed_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, Simulate_physics) == 0x000010, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::Simulate_physics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Grab_Weapon, Use_gravity) == 0x000011, "Member 'DragonIKWeaponPhysicsComponent_Grab_Weapon::Use_gravity' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Only
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Release_Hand_Only final
{
public:
	class FName                                   Hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Release_Hand_Only) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Release_Hand_Only");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Release_Hand_Only) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Release_Hand_Only");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Only, Hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Only::Hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Plus_Override
// 0x0080 (0x0080 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override final
{
public:
	class FName                                   Hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F7[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Hand_transform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_hand_location;                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_Hand_Rotation;                            // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F8[0xE];                                     // 0x0072(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override) == 0x000080, "Wrong size on DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, Hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::Hand_bone' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, Hand_transform) == 0x000010, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::Hand_transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, Override_hand_location) == 0x000070, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::Override_hand_location' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override, Override_Hand_Rotation) == 0x000071, "Member 'DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override::Override_Hand_Rotation' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Weapon
// 0x0003 (0x0003 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Release_Weapon final
{
public:
	bool                                          Should_simulatephysics;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_gravity;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeep_Attachment;                                  // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Release_Weapon) == 0x000001, "Wrong alignment on DragonIKWeaponPhysicsComponent_Release_Weapon");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Release_Weapon) == 0x000003, "Wrong size on DragonIKWeaponPhysicsComponent_Release_Weapon");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Weapon, Should_simulatephysics) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Release_Weapon::Should_simulatephysics' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Weapon, Use_gravity) == 0x000001, "Member 'DragonIKWeaponPhysicsComponent_Release_Weapon::Use_gravity' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Release_Weapon, bKeep_Attachment) == 0x000002, "Member 'DragonIKWeaponPhysicsComponent_Release_Weapon::bKeep_Attachment' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Unfreeze_Elbows_Function
// 0x0008 (0x0008 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function final
{
public:
	class FName                                   Hand_bone;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function) == 0x000004, "Wrong alignment on DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function) == 0x000008, "Wrong size on DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function, Hand_bone) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function::Hand_bone' has a wrong offset!");

// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Weapon_Transform_Override
// 0x0070 (0x0070 - 0x0000)
struct DragonIKWeaponPhysicsComponent_Weapon_Transform_Override final
{
public:
	struct FTransform                             Weapon_Transform;                                  // 0x0000(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShould_Override_Weapon_Transform;                 // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F9[0xF];                                     // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override) == 0x000010, "Wrong alignment on DragonIKWeaponPhysicsComponent_Weapon_Transform_Override");
static_assert(sizeof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override) == 0x000070, "Wrong size on DragonIKWeaponPhysicsComponent_Weapon_Transform_Override");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override, Weapon_Transform) == 0x000000, "Member 'DragonIKWeaponPhysicsComponent_Weapon_Transform_Override::Weapon_Transform' has a wrong offset!");
static_assert(offsetof(DragonIKWeaponPhysicsComponent_Weapon_Transform_Override, bShould_Override_Weapon_Transform) == 0x000060, "Member 'DragonIKWeaponPhysicsComponent_Weapon_Transform_Override::bShould_Override_Weapon_Transform' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.CustomLookRotation
// 0x0048 (0x0048 - 0x0000)
struct DragonIK_Library_CustomLookRotation final
{
public:
	struct FVector                                LookAt;                                            // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpDirection;                                       // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_CustomLookRotation) == 0x000008, "Wrong alignment on DragonIK_Library_CustomLookRotation");
static_assert(sizeof(DragonIK_Library_CustomLookRotation) == 0x000048, "Wrong size on DragonIK_Library_CustomLookRotation");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, LookAt) == 0x000000, "Member 'DragonIK_Library_CustomLookRotation::LookAt' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, UpDirection) == 0x000018, "Member 'DragonIK_Library_CustomLookRotation::UpDirection' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, ReturnValue) == 0x000030, "Member 'DragonIK_Library_CustomLookRotation::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.LookAtRotation_V3
// 0x0060 (0x0060 - 0x0000)
struct DragonIK_Library_LookAtRotation_V3 final
{
public:
	struct FVector                                Source;                                            // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpVector;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_LookAtRotation_V3) == 0x000008, "Wrong alignment on DragonIK_Library_LookAtRotation_V3");
static_assert(sizeof(DragonIK_Library_LookAtRotation_V3) == 0x000060, "Wrong size on DragonIK_Library_LookAtRotation_V3");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, Source) == 0x000000, "Member 'DragonIK_Library_LookAtRotation_V3::Source' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, Target) == 0x000018, "Member 'DragonIK_Library_LookAtRotation_V3::Target' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, UpVector) == 0x000030, "Member 'DragonIK_Library_LookAtRotation_V3::UpVector' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, ReturnValue) == 0x000048, "Member 'DragonIK_Library_LookAtRotation_V3::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.LookAtVector_V2
// 0x0060 (0x0060 - 0x0000)
struct DragonIK_Library_LookAtVector_V2 final
{
public:
	struct FVector                                Source_Location;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAt;                                            // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpDirection;                                       // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_LookAtVector_V2) == 0x000008, "Wrong alignment on DragonIK_Library_LookAtVector_V2");
static_assert(sizeof(DragonIK_Library_LookAtVector_V2) == 0x000060, "Wrong size on DragonIK_Library_LookAtVector_V2");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, Source_Location) == 0x000000, "Member 'DragonIK_Library_LookAtVector_V2::Source_Location' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, LookAt) == 0x000018, "Member 'DragonIK_Library_LookAtVector_V2::LookAt' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, UpDirection) == 0x000030, "Member 'DragonIK_Library_LookAtVector_V2::UpDirection' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, ReturnValue) == 0x000048, "Member 'DragonIK_Library_LookAtVector_V2::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.QuatLookXatLocation
// 0x00E0 (0x00E0 - 0x0000)
struct DragonIK_Library_QuatLookXatLocation final
{
public:
	struct FTransform                             LookAtFromTransform;                               // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtTarget;                                      // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FB[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0080(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_QuatLookXatLocation) == 0x000010, "Wrong alignment on DragonIK_Library_QuatLookXatLocation");
static_assert(sizeof(DragonIK_Library_QuatLookXatLocation) == 0x0000E0, "Wrong size on DragonIK_Library_QuatLookXatLocation");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, LookAtFromTransform) == 0x000000, "Member 'DragonIK_Library_QuatLookXatLocation::LookAtFromTransform' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, LookAtTarget) == 0x000060, "Member 'DragonIK_Library_QuatLookXatLocation::LookAtTarget' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, ReturnValue) == 0x000080, "Member 'DragonIK_Library_QuatLookXatLocation::ReturnValue' has a wrong offset!");

}

