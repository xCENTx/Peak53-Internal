#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_MasterWeapon

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "E_AttachmentType_structs.hpp"
#include "S_MinMax_structs.hpp"
#include "E_DamageType_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "S_Damage_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "BP_MasterHoldable_classes.hpp"
#include "E_Hitbox_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_MasterWeapon.BP_MasterWeapon_C
// 0x0230 (0x08E0 - 0x06B0)
#pragma pack(push, 0x1)
class alignas(0x10) ABP_MasterWeapon_C : public ABP_MasterHoldable_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_MasterWeapon_C;                  // 0x06B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	TArray<class UClass*>                         AllowedAttachments;                                // 0x06B8(0x0010)(Edit, BlueprintVisible)
	TArray<struct FDataTableRowHandle>            DefaultAttachments;                                // 0x06C8(0x0010)(Edit, BlueprintVisible)
	TSet<E_AttachmentType>                        AvalibleAttachmentSlot;                            // 0x06D8(0x0050)(Edit, BlueprintVisible)
	class UBP_WeaponInventory_C*                  WeaponInventory;                                   // 0x0728(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TArray<struct FS_Damage>                      Damage;                                            // 0x0730(0x0010)(Edit, BlueprintVisible)
	class ABP_MasterAttachment_C*                 NewAttachment;                                     // 0x0740(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMap<EPhysicalSurface, class USoundBase*>     HitSurfaceSounds;                                  // 0x0748(0x0050)(Edit, BlueprintVisible)
	TMap<EPhysicalSurface, class UMaterialInterface*> HitSurfaceDecals;                                  // 0x0798(0x0050)(Edit, BlueprintVisible)
	TMap<EPhysicalSurface, class UNiagaraSystem*> HitSurfaceParticles;                               // 0x07E8(0x0050)(Edit, BlueprintVisible)
	TMap<EPhysicalSurface, struct FVector>        DecalSize;                                         // 0x0838(0x0050)(Edit, BlueprintVisible)
	double                                        DecalLifeSpan;                                     // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        Decal_Fade_Distance;                               // 0x0890(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseDurabilityCheck;                                // 0x0898(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowAttackingInStandardStance;                    // 0x0899(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ApplyBleedDamage;                                  // 0x089A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5574[0x5];                                     // 0x089B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        BleedTickTime;                                     // 0x08A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          RandomlyApplyBleed;                                // 0x08A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5575[0x3];                                     // 0x08A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_MinMax                              BleedTickDamage;                                   // 0x08AC(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5576[0x4];                                     // 0x08B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        BleedApplyChance;                                  // 0x08B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        BleedLength;                                       // 0x08C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_DamageType                                  DamageType;                                        // 0x08C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5577[0x7];                                     // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        CurrentSound;                                      // 0x08D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)

public:
	void AddNewAttachment(class UClass* Param_Class, const struct FS_InvItem& AttachmentItem, bool PlayAnim, class ABP_MasterAttachment_C** Param_NewAttachment);
	void ApplyAttachmentDamage(class ABP_MasterAttachment_C* Attachment, bool Add);
	void ApplyHitActorDamage(class AActor* HitActor, class FName HitBone, TArray<struct FS_Damage>& Param_Damage);
	void ApplyWeaponAttachmentStats(class ABP_MasterAttachment_C* Attachment);
	void AttackStanceCheck(bool* AllowAttack);
	bool DurabilityCheck();
	void ExecuteUbergraph_BP_MasterWeapon(int32 EntryPoint);
	void MulticastHitSurfaceEffects(const struct FHitResult& HitResult);
	void MulticastPlayMontage(class UAnimMontage* Montage);
	void MulticastPlayWeaponMeshAnimation(class UAnimSequenceBase* Animation);
	void OnBlendOut_8390FA13400A16AA738DBD972414B766(class FName NotifyName);
	void OnCompleted_8390FA13400A16AA738DBD972414B766(class FName NotifyName);
	void OnInterrupted_8390FA13400A16AA738DBD972414B766(class FName NotifyName);
	void OnNotifyBegin_8390FA13400A16AA738DBD972414B766(class FName NotifyName);
	void OnNotifyEnd_8390FA13400A16AA738DBD972414B766(class FName NotifyName);
	bool PlayAttachWeaponAnim(class ABP_MasterAttachment_C* Attachment, const struct FS_AttachmentDetails& AttachmentDetails);
	bool PlayDetachWeaponAnim(class ABP_MasterAttachment_C* Attachment, const struct FS_AttachmentDetails& AttachmentDetails);
	void ReceiveBeginPlay();
	void RemoveWeaponAttchmentStats(class ABP_MasterAttachment_C* Attachment);
	void SGK_AttachNewAttachment(class ABP_MasterAttachment_C* Attachment, const struct FS_InvItem& InvItem, E_AttachmentType AttachmentType);
	void SGK_ShowNewAttachment();
	void SpawnHitSurfaceDecal(const struct FHitResult& HitResult);
	void SpawnHitSurfaceParticle(const struct FHitResult& HitResult);
	void SpawnHitSurfaceSound(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_MasterWeapon_C">();
	}
	static class ABP_MasterWeapon_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_MasterWeapon_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABP_MasterWeapon_C) == 0x000010, "Wrong alignment on ABP_MasterWeapon_C");
static_assert(sizeof(ABP_MasterWeapon_C) == 0x0008E0, "Wrong size on ABP_MasterWeapon_C");
static_assert(offsetof(ABP_MasterWeapon_C, UberGraphFrame_BP_MasterWeapon_C) == 0x0006B0, "Member 'ABP_MasterWeapon_C::UberGraphFrame_BP_MasterWeapon_C' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, AllowedAttachments) == 0x0006B8, "Member 'ABP_MasterWeapon_C::AllowedAttachments' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, DefaultAttachments) == 0x0006C8, "Member 'ABP_MasterWeapon_C::DefaultAttachments' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, AvalibleAttachmentSlot) == 0x0006D8, "Member 'ABP_MasterWeapon_C::AvalibleAttachmentSlot' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, WeaponInventory) == 0x000728, "Member 'ABP_MasterWeapon_C::WeaponInventory' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, Damage) == 0x000730, "Member 'ABP_MasterWeapon_C::Damage' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, NewAttachment) == 0x000740, "Member 'ABP_MasterWeapon_C::NewAttachment' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, HitSurfaceSounds) == 0x000748, "Member 'ABP_MasterWeapon_C::HitSurfaceSounds' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, HitSurfaceDecals) == 0x000798, "Member 'ABP_MasterWeapon_C::HitSurfaceDecals' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, HitSurfaceParticles) == 0x0007E8, "Member 'ABP_MasterWeapon_C::HitSurfaceParticles' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, DecalSize) == 0x000838, "Member 'ABP_MasterWeapon_C::DecalSize' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, DecalLifeSpan) == 0x000888, "Member 'ABP_MasterWeapon_C::DecalLifeSpan' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, Decal_Fade_Distance) == 0x000890, "Member 'ABP_MasterWeapon_C::Decal_Fade_Distance' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, UseDurabilityCheck) == 0x000898, "Member 'ABP_MasterWeapon_C::UseDurabilityCheck' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, AllowAttackingInStandardStance) == 0x000899, "Member 'ABP_MasterWeapon_C::AllowAttackingInStandardStance' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, ApplyBleedDamage) == 0x00089A, "Member 'ABP_MasterWeapon_C::ApplyBleedDamage' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, BleedTickTime) == 0x0008A0, "Member 'ABP_MasterWeapon_C::BleedTickTime' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, RandomlyApplyBleed) == 0x0008A8, "Member 'ABP_MasterWeapon_C::RandomlyApplyBleed' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, BleedTickDamage) == 0x0008AC, "Member 'ABP_MasterWeapon_C::BleedTickDamage' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, BleedApplyChance) == 0x0008B8, "Member 'ABP_MasterWeapon_C::BleedApplyChance' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, BleedLength) == 0x0008C0, "Member 'ABP_MasterWeapon_C::BleedLength' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, DamageType) == 0x0008C8, "Member 'ABP_MasterWeapon_C::DamageType' has a wrong offset!");
static_assert(offsetof(ABP_MasterWeapon_C, CurrentSound) == 0x0008D0, "Member 'ABP_MasterWeapon_C::CurrentSound' has a wrong offset!");

}

