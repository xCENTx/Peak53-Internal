#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerInventory

#include "Basic.hpp"

#include "S_InvSlotID_structs.hpp"
#include "S_WeaponSlot_structs.hpp"
#include "Engine_structs.hpp"
#include "E_EquipmentType_structs.hpp"
#include "S_InvSlot_structs.hpp"
#include "E_DamageType_structs.hpp"
#include "E_CraftingType_structs.hpp"
#include "E_CharacterState_structs.hpp"
#include "E_WeaponSlots_structs.hpp"
#include "E_ItemMoveType_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "S_AttachmentSlot_structs.hpp"
#include "S_InvItem_structs.hpp"
#include "S_StatReduction_structs.hpp"
#include "Peak53Teams_structs.hpp"
#include "E_CrosshairType_structs.hpp"
#include "E_AnimationState_structs.hpp"
#include "S_ContainerDetails_structs.hpp"
#include "BP_EquipmentInventory_classes.hpp"
#include "E_Hitbox_structs.hpp"
#include "E_SpecialSlotType_structs.hpp"
#include "E_WorldActions_structs.hpp"
#include "E_InventoryActions_structs.hpp"
#include "E_CameraType_structs.hpp"
#include "E_Sounds_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PlayerInventory.BP_PlayerInventory_C
// 0x09E8 (0x10B0 - 0x06C8)
class UBP_PlayerInventory_C final : public UBP_EquipmentInventory_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_PlayerInventory_C;               // 0x06C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UCameraComponent*                       CurrentCamera;                                     // 0x06D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FHitResult                             ClientInteractHitResult;                           // 0x06D8(0x00E8)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, ContainsInstancedReference)
	class UBP_MasterInventory_C*                  ExtCookingComponent;                               // 0x07C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_WeaponInventory_C*                  NewAttachmentWeaponInventory;                      // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_MasterInventory_C*                  ExtCraftingComponent;                              // 0x07D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterComponent_C*               CharacterComponent;                                // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerBuildingComponent_C*          PlayerBuildingComponent;                           // 0x07E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          DisableCharMovement;                               // 0x07E8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B41[0x7];                                     // 0x07E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_MasterInventory_C*                  VenderComponent;                                   // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_MasterInventory_C*                  ExtInventoryComponent;                             // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          InventoryOpen;                                     // 0x0800(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B42[0x7];                                     // 0x0801(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InteractedActor;                                   // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         CurrentHealth;                                     // 0x0810(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B43[0x4];                                     // 0x0814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CurrentHunger;                                     // 0x0818(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	double                                        CurrentThirst;                                     // 0x0820(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	double                                        CurrentStamina;                                    // 0x0828(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	E_CharacterState                              CurrentCharacterState;                             // 0x0830(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMoving;                                          // 0x0831(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SprintKeyDown;                                     // 0x0832(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B44[0x5];                                     // 0x0833(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           UseStaminaTimer;                                   // 0x0838(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           RechargeStaminaTimer;                              // 0x0840(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          BlockInput;                                        // 0x0848(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B45[0x7];                                     // 0x0849(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           StarvationTimer;                                   // 0x0850(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           DehydrationTimer;                                  // 0x0858(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class ABP_MasterHoldable_C*                   NewHoldingItem;                                    // 0x0860(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class ACharacter*                             SGKCharacter;                                      // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FS_InvSlot                             HoldingInvSlot;                                    // 0x0870(0x0050)(Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FS_InvSlot                             NewHoldingInvSlot;                                 // 0x08C0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FS_WeaponSlot                          NewHoldingWeaponSlot;                              // 0x0910(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	E_ItemMoveType                                CurrentHoldingType;                                // 0x0960(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_ItemMoveType                                NewHoldingType;                                    // 0x0961(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          InAttack;                                          // 0x0962(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSplitKeyDown;                                    // 0x0963(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B46[0x4];                                     // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_WeaponSlot                          HoldingWeaponSlot;                                 // 0x0968(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          Equipping;                                         // 0x09B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B47[0x7];                                     // 0x09B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_AttachmentSlot                      RemoveAttachmentSlot;                              // 0x09C0(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          DropRemoveAttachent;                               // 0x0A08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B48[0x7];                                     // 0x0A09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_InvSlotID                           RemoveSlotTarget;                                  // 0x0A10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          RotatedAttachTarget;                               // 0x0A20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B49[0x7];                                     // 0x0A21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_InvSlotID                           NewAttachmentID;                                   // 0x0A28(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	class ABP_MasterAttachment_C*                 NewAttachment;                                     // 0x0A38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class AController*                            DeathController;                                   // 0x0A40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          SwapAttachment;                                    // 0x0A48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4A[0x7];                                     // 0x0A49(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_InvItem                             AttachingItem;                                     // 0x0A50(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	class ACharacter*                             RespawnedCharacter;                                // 0x0A80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           DeadBodyTimer;                                     // 0x0A88(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class FText                                   PlayerName;                                        // 0x0A90(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance)
	class ACharacter*                             DeadCharacter;                                     // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<struct FDataTableRowHandle>            CraftingRecipes;                                   // 0x0AB0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          Respawned;                                         // 0x0AC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4B[0x7];                                     // 0x0AC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 DeadCharacterClass;                                // 0x0AC8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           SprintCheckTimer;                                  // 0x0AD0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FHitResult                             ServerHitResult;                                   // 0x0AD8(0x00E8)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, ContainsInstancedReference)
	bool                                          BuildMode;                                         // 0x0BC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Bleeding;                                          // 0x0BC1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UIOpen;                                            // 0x0BC2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4C[0x1];                                     // 0x0BC3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Tick_Damage;                                       // 0x0BC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          QuickMoveKeyDown;                                  // 0x0BC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4D[0x7];                                     // 0x0BC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           BleedDamageTimer;                                  // 0x0BD0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UBP_DeathScreen_C*                      RespawnHUD;                                        // 0x0BD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class FText                                   RespawnPointName;                                  // 0x0BE0(0x0018)(Edit, BlueprintVisible, Net, DisableEditOnInstance)
	double                                        CameraLean;                                        // 0x0BF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        CharacterLean;                                     // 0x0C00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_InventoryHUD_C*                     PlayerHUD;                                         // 0x0C08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class USpringArmComponent*                    CurrentSpringArm;                                  // 0x0C10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	double                                        InteractionDistance;                               // 0x0C18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETraceTypeQuery                               InteractionTraceChannel;                           // 0x0C20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4E[0x3];                                     // 0x0C21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuickSlots;                                        // 0x0C24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MaxQuickSlots;                                     // 0x0C28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MaxHealth;                                         // 0x0C2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         StartingHealth;                                    // 0x0C30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4F[0x4];                                     // 0x0C34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxStamina;                                        // 0x0C38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StartingStamina;                                   // 0x0C40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<E_CharacterState, double>                StaminaReduction;                                  // 0x0C48(0x0050)(Edit, BlueprintVisible)
	TMap<E_CharacterState, double>                StaminaReductionTime;                              // 0x0C98(0x0050)(Edit, BlueprintVisible)
	TMap<E_CharacterState, double>                StaminaRecharge;                                   // 0x0CE8(0x0050)(Edit, BlueprintVisible)
	TMap<E_CharacterState, bool>                  StaminaMovementStates;                             // 0x0D38(0x0050)(Edit, BlueprintVisible)
	bool                                          UseThirst;                                         // 0x0D88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B50[0x7];                                     // 0x0D89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS_StatReduction>               ThirstReduction;                                   // 0x0D90(0x0010)(Edit, BlueprintVisible)
	double                                        MaxThirst;                                         // 0x0DA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StartingThirst;                                    // 0x0DA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        ThirstReductionTime;                               // 0x0DB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         DehydrationDamage;                                 // 0x0DB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B51[0x4];                                     // 0x0DBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DehydrationDamageTime;                             // 0x0DC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseHunger;                                         // 0x0DC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B52[0x7];                                     // 0x0DC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS_StatReduction>               HungerReduction;                                   // 0x0DD0(0x0010)(Edit, BlueprintVisible)
	double                                        MaxHunger;                                         // 0x0DE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StartingHunger;                                    // 0x0DE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StarvationDamageTime;                              // 0x0DF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         StarvationDamage;                                  // 0x0DF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B53[0x4];                                     // 0x0DFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        HungerReductionTime;                               // 0x0E00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<E_CharacterState, double>                MovementSpeeds;                                    // 0x0E08(0x0050)(Edit, BlueprintVisible)
	FMulticastInlineDelegateProperty_             RotateMoveWidget;                                  // 0x0E58(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             InventoryToggled;                                  // 0x0E68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FVector2D                              InventorySlotSize;                                 // 0x0E78(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowDroppingHeldItem;                             // 0x0E88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseNotificationSounds;                             // 0x0E89(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B54[0x6];                                     // 0x0E8A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             WarningNotifySound;                                // 0x0E90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	bool                                          ClearInventoryOnDeath;                             // 0x0E98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B55[0x7];                                     // 0x0E99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DeathSound;                                        // 0x0EA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	bool                                          ClearLearnRecipesOnDeath;                          // 0x0EA8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DeletePlayerSaveOnDeath;                           // 0x0EA9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B56[0x6];                                     // 0x0EAA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DeadBodyDespawnTime;                               // 0x0EB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EDrawDebugTrace                               InteractionTraceDebug;                             // 0x0EB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B57[0x7];                                     // 0x0EB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             TakeDamageSound;                                   // 0x0EC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	bool                                          UseHealthRegeneration;                             // 0x0EC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B58[0x3];                                     // 0x0EC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRegenerationTickAmount;                      // 0x0ECC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MinHealthRegenerationHunger;                       // 0x0ED0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MinHealthRegenerationThirst;                       // 0x0ED8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        RegenerationTickTime;                              // 0x0EE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseFallDamage;                                     // 0x0EE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B59[0x7];                                     // 0x0EE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        FallDamage;                                        // 0x0EF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StartFallDamageTime;                               // 0x0EF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        FallDamageIncreeseTime;                            // 0x0F00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        FallDamageVelocity;                                // 0x0F08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ResourceHarvestAmount;                             // 0x0F10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseLearnableRecipes;                               // 0x0F14(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B5A[0x3];                                     // 0x0F15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            StartingCraftingRecipes;                           // 0x0F18(0x0010)(Edit, BlueprintVisible)
	E_AnimationState                              DefaultStance;                                     // 0x0F28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowStanceChange;                                 // 0x0F29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowLeaningInCombatStance;                        // 0x0F2A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowLeaningInStandardStance;                      // 0x0F2B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B5B[0x4];                                     // 0x0F2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ThirdPersonCameraOffset;                           // 0x0F30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        RepairActorRange;                                  // 0x0F38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<E_CharacterState, double>                StaminaRechargeTime;                               // 0x0F40(0x0050)(Edit, BlueprintVisible)
	bool                                          AllowInteractionWhileInAction;                     // 0x0F90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DebugInteractionTrace;                             // 0x0F91(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B5C[0x6];                                     // 0x0F92(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 IgnoreInteractActor;                               // 0x0F98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FRotator                               LastCharacterRotation;                             // 0x0FA0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FVector                                LastCharacterLocation;                             // 0x0FB8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseLearnableExternalRecipes;                       // 0x0FD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B5D[0x7];                                     // 0x0FD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             CloseInventorySound;                               // 0x0FD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class USoundBase*                             OpenInventorySound;                                // 0x0FE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	bool                                          SaveFound;                                         // 0x0FE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_CraftingType                                PlayerCraftingType;                                // 0x0FE9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B5E[0x6];                                     // 0x0FEA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS_ContainerDetails                    PlayerInventoryDetails;                            // 0x0FF0(0x0070)(Edit, BlueprintVisible, ContainsInstancedReference, HasGetValueTypeHash)
	double                                        SearchEnemyDistance;                               // 0x1060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 EnemyInstigator;                                   // 0x1068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	EPeak53Teams                                  PlayerTeam;                                        // 0x1070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B5F[0x7];                                     // 0x1071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             PlayerDied;                                        // 0x1078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UBP_QuickSlot_C*                        BQuickSlotL;                                       // 0x1088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          bVictoryDance;                                     // 0x1090(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B60[0x7];                                     // 0x1091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   RandomDance;                                       // 0x1098(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         Greande1Amount;                                    // 0x10A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Grenade2Amount;                                    // 0x10AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void AddAllEquipmentQuickSlots();
	void AddAmmoToRangeWeapon(const struct FS_InvSlot& WeaponSlot, const struct FS_InvSlot& StartSlot, bool Split, bool ShowNotification);
	bool AddAttachmentFromSlot(const struct FS_InvSlotID& Attachment_Item_ID, class UBP_WeaponInventory_C* WeaponInventory, bool ShowNotifications);
	void AddItemToContainer(const struct FS_InvItem& Item, const struct FS_InvSlot& ContainerSlot, bool* RemainingItem, struct FS_InvItem* InvItem);
	void AddNewInvPanel(class UBP_MasterInventory_C* Param_Inventory, bool Internal);
	void AddQuickSlots(const struct FS_InvItem& EquipmentItem, class UBP_MasterInventory_C* Param_Inventory);
	bool AllRepairActorCheck(TArray<struct FS_RepairActors>& RepairActors);
	void ApplyAttachment(const struct FS_InvSlotID& AttachmentItemID, class UBP_WeaponInventory_C* WeaponInventory, bool SpawnAttachment, bool ShowNotifications);
	void AttachNewAttachment();
	void AttemptToAddItem(const struct FS_InvItem& InvItem, bool StackSearch, bool ShowNotifications, bool* RemainingItem, struct FS_InvItem* RemainingInvItem, struct FS_InvSlotID* NewItemSlot);
	void AttemptToAddItemToSlot(const struct FS_InvSlot& Inv_Item_ID, const struct FDataTableRowHandle& Item, int32 Amount);
	void AttemptToEquipItem(const struct FS_InvItem& InvItem, bool* ItemEquipped);
	void AttemptToEquipWeapon(const struct FS_InvItem& InvItem, bool ShowNotification, bool* WeaponEquipped, E_WeaponSlots* ItemWeaponSlot);
	void AttemptToHoldItem(const struct FS_InvSlot& InvSlot, bool* ItemHeld);
	void AttemptToPickupHold(const struct FS_InvItem& InvItem, bool* ItemHeld, bool* ItemAdded);
	void BeginPlayInventory();
	void BleedDamage();
	void CancelCraftingQueue(const struct FS_CraftingQueue& CancelQueue, class UBP_MasterInventory_C* CraftingInventory);
	void CancelReload();
	bool CanInteract();
	void ChangeState(E_CharacterState NewState);
	void CheckFFA(bool* FFA_);
	void CheckRecipeCost(class FName Recipe, int32 Amount, bool RemoveItems, bool* CanCraft);
	void ClearBleed();
	void ClearContainerQuickSlots(class UBP_MasterInventory_C* InvComponent);
	void ClientAddCraftingListing(const struct FS_CraftingQueue& NewQueueListing, class UBP_MasterInventory_C* CraftingInventory);
	void ClientAddQuickSlots(int32 AddAmount);
	void ClientClearCurrentItems(class UBP_MasterInventory_C* Param_Inventory);
	void ClientClearQuickSlotItem(int32 QuickSlotIndex);
	void ClientCloseContainerWindow(class UBP_MasterInventory_C* Param_Inventory);
	void ClientCloseInventory();
	void ClientCloseLockpad();
	void ClientCodeResult(bool Accepted);
	void ClientCreateNotification(const struct FS_NotificationDetails& NotificationDetails);
	void ClientDisableRespawnScreen();
	void ClientInteract();
	void ClientOpenContainerInv(class UBP_MasterInventory_C* Param_Inventory, bool Param_ToggleInventory, TArray<struct FS_InvSlot>& InventorySlots);
	void ClientOpenExtCookingMenu(class UBP_MasterInventory_C* CookingInventory, const TArray<struct FS_InvSlot>& Param_Inventory, const TArray<struct FS_CookingSlot>& CookingSlots);
	void ClientOpenExtCraftingMenu(class UBP_MasterInventory_C* MasterInventory, const TArray<struct FS_InvSlot>& Param_Inventory, const TArray<struct FS_CraftingQueue>& Param_CraftingQueue, bool CraftingBlocked);
	void ClientOpenExtEquipmentInv(class UBP_EquipmentInventory_C* EquipmentInventory, const TArray<struct FS_InvSlot>& Param_Inventory);
	void ClientOpenExtInv(class UBP_MasterInventory_C* MasterInventory, const TArray<struct FS_InvSlot>& Param_Inventory);
	void ClientOpenLockpad(bool SetCode, class AActor* Lock);
	void ClientOpenVenderMenu(class UBP_MasterInventory_C* Param_VenderComponent, const TArray<struct FS_InvSlot>& Param_Inventory);
	void ClientOpenWeaponWindow(class UBP_WeaponInventory_C* Param_Inventory, bool Param_ToggleInventory);
	void UnPauseCookingSlot(int32 Param_Index, bool Pause);
	void ClientPauseAllCookingSlotTimers();
	void ClientPauseCraftingListing();
	void ClientPlaceNamedBuildPart(const class FText& Param_Name);
	void ClientPlayerInventoryRepawned();
	void ClientPrimaryAction(bool KeyDown);
	void ClientQuickSlotHighlight(int32 QuickSlotIndex, bool Highlight);
	void ClientRefreshCraftingList(const TArray<struct FDataTableRowHandle>& Recipes);
	void ClientRefreshGrids();
	void ClientReloadChecks();
	void ClientRemoveInventory();
	void ClientRemoveInvPanel(class UBP_MasterInventory_C* Param_Inventory, bool Condition);
	void ClientRemoveQuickSlots(int32 RemoveAmount);
	void ClientRespawnPlayer(bool Random);
	void ClientRestartConvertSlotTimer(const struct FS_CookingSlot& CookingSlot);
	void ClientResumeCookingSlotTimer(const struct FS_CookingSlot& CookingSlot);
	void ClientResumeCraftingListing();
	void ClientSecondaryAction(bool KeyDown);
	void ClientSelfInventoryPanel();
	void ClientSetControlRotation(class AController* Controller, const struct FRotator& Rotation);
	void ClientSetCookingInventorySlot(const TArray<struct FS_InvSlot>& NewParam);
	void ClientSetExtInvDetails(const struct FS_ContainerDetails& Details, class UBP_MasterInventory_C* Param_Inventory);
	void ClientSetIgnoreActor(class AActor* Param_IgnoreInteractActor);
	void ClientSetInventoryOpen(const bool Param_InventoryOpen);
	void ClientSetPlayerName(const class FText& Param_PlayerName);
	void ClientShowRespawnScreen();
	void ClientStartCookingSlotTimer(const struct FS_CookingSlot& CookingSlot);
	void ClientStartCraftingListingTimer(class FName CraftingRecipe, class UBP_MasterInventory_C* CraftingInventory);
	void ClientUpdateAttachment(class UBP_MasterInventory_C* Param_Inventory);
	void ClientUpdateAttachmentItems(const TArray<struct FS_AttachmentSlot>& Attachments, const class UBP_WeaponInventory_C* WeaponInventory);
	void ClientUpdateCookingSlot(const struct FS_InvSlot& CookingSlot);
	void ClientUpdateCraftingListing(const struct FS_CraftingQueue& ListingQueue, class UBP_MasterInventory_C* CraftingInventory);
	void ClientUpdateEquipmentSlot(const struct FS_EquipmentSlot& EquipmentSlot);
	void ClientUpdateInvSlot(const struct FS_InvSlot& RootInvSlot, int32 HeightSlots, int32 WidthSlots, bool Rotated);
	void ClientUpdateItemSlots(const TArray<struct FS_InvSlot>& Slots, const struct FS_ContainerDetails& Param_InventoryDetails, class UBP_MasterInventory_C* Param_Inventory);
	void ClientUpdateQuickSlot(const struct FS_InvSlotID& InvSlotID, int32 QuickSlotIndex);
	void ClientUpdateSlotsWithItems(const TArray<struct FS_InvSlot>& Slots, class UBP_MasterInventory_C* Param_Inventory);
	void ClientUpdateState(E_CharacterState CharacterState);
	void ClientUpdateStatUI();
	void ClientUpdateWeaponQuickSlot(const struct FS_WeaponSlotID& WeaponSlotID, int32 QuickSlotID);
	void ClientUpdateWeaponSlot(const struct FS_WeaponSlot& Weapon_Slot);
	void ClientUseQuickSlot(int32 QuickSlotIndex, bool InstantPlacement);
	void CloseCodeLockUI();
	void CloseInventory();
	void CombineSlotStacks(const struct FS_InvSlot& StartSlot, const struct FS_InvSlot& EndSlot, bool SplitStack, E_SpecialSlotType SpecialType, bool ShowNotifications);
	void ConsumeItem(const struct FS_InvItem& Item, bool* Consumed);
	void ContextMenu(class UBP_InteractionContextMenu_C** Param_ContextMenu);
	void CreateNotificationInChild(const struct FS_NotificationDetails& NotificationDetails);
	void DecreaseHealth(int32 Amount, bool PlayTakeDamageSound, bool bFallDamage_);
	void DecreaseHeldItemDurability(double DecreaseAmount);
	void DecreaseHunger(double Amount);
	void DecreaseStamina(double Amount);
	void DecreaseThirst(double Amount);
	void DehydrationState();
	void DelayPlace();
	void DelayPlayMontage(class UAnimMontage* Montage);
	void DelaySelfDeactivateDance();
	void DestroyCharacterBody();
	void DestroyDeadCharacterBody();
	void DestroyEquipmentItem(E_EquipmentType EquipmentSlot);
	void DropBombInput();
	void DropFlagInput();
	void DropItemFromSlot(const struct FS_InvSlotID& SlotID, E_SpecialSlotType SpecialType, bool Split);
	void EndInteraction();
	void EquipItemFromSlot(const struct FS_InvSlotID& SlotID, const struct FS_EquipmentSlotID& EquipmentSlotID);
	void EquipWeaponFromSlot(const struct FS_InvSlotID& Slot_ID, const struct FS_WeaponSlotID& Weapon_Slot_ID);
	void ExecuteUbergraph_BP_PlayerInventory(int32 EntryPoint);
	void FindAttachmentSlot(class UBP_MasterInventory_C* Param_Inventory);
	bool FindCompatiableWeaponSlot(const struct FS_InvItem& WeaponItem, E_WeaponSlots* Slot);
	void FindMontage(const TMap<class USkeletalMesh*, class UAnimMontage*>& TargetMap, bool* AnimFound, class UAnimMontage** Montage);
	void FindQuickSlot(int32 QuickSlotIndex, class UBP_QuickSlot_C** OutputSlot);
	void FindSpawnPoint(bool Random, struct FTransform* SpawnLocation);
	void HealthRegeneration();
	void HitActor(const struct FHitResult& Hit, class AActor** Param_HitActor, class UPrimitiveComponent** HitComponent);
	bool HoldingItemCheck(const struct FS_InvSlot& InvSlot);
	bool HoldingWeaponCheck(const struct FS_WeaponSlot& WeaponSlot);
	void HungerState();
	void InAction(bool* Param_InAction);
	void IncreaseHealth(int32 Amount);
	void IncreaseHunger(double Amount);
	void IncreaseStamina(double Amount);
	void IncreaseThirst(double Amount);
	void InGameLoadComponentData(class UBP_SGKSaveGame_C* Save);
	void InGameLoadPlayerInventory(class UBP_SGKSaveGame_C* Save);
	void InitializePlayerInventory();
	void InpActEvt_Dance_K2Node_InputActionEvent_0(const struct FKey& Key);
	void InteractionMath(E_CameraType CameraView, double TraceDistance, struct FVector* Start, struct FVector* End);
	void InteractTrace(const struct FVector& Start, const struct FVector& End, E_WorldActions ActionType);
	void InventoryToggled__DelegateSignature(bool Open);
	bool IsInNoDamageZone();
	void IsInPlayerInv(class UBP_MasterInventory_C* InventoryComponent, bool* Param_IsInPlayerInv);
	void IsInventoryEquipped(class UBP_MasterInventory_C* ItemInv, class UBP_EquipmentInventory_C* EquipmentInv, bool* IsEquipped);
	bool IsItemHeld(class FName Item_ID);
	void ItemActionCheck(const struct FS_InvItem& Item, E_InventoryActions Action, bool* AllowUse);
	bool KnownRecipeCheck(const struct FDataTableRowHandle& RecipeDataHandle);
	bool LeanCheck();
	void LearnAllItemRecipes(const struct FS_InvItem& InvItem, bool* RecipeLearnt);
	bool LearnNewRecipe(const struct FDataTableRowHandle& RecipeDataHandle);
	void LoadComponentData(class UBP_SGKSaveGame_C* SaveGame, bool* LoadComplete);
	void LoadPlayerInventory(bool LoadLocation);
	void LookAtTrace();
	void MC_DisableCollisions();
	void MoveAddToContainer(const struct FS_InvSlot& StartSlot, const struct FS_InvSlot& EndSlot, bool Split, bool ShowNotification);
	bool MoveAttachmentAddToContainer(const struct FS_AttachmentSlotID& Attachment_ID, const struct FS_InvSlot& EndSlot, bool ChecksOnly);
	void MoveItem(const struct FS_InvSlotID& StartSlotID, const struct FS_InvSlotID& EndSlotID, bool Rotated, bool Split, E_SpecialSlotType SpecialType, bool ShowNotifications, bool* ItemMoved);
	void MovementInput();
	void MulticastInitPlayerInventory();
	void MulticastPlayFlagDropped();
	void OnRep_bVictoryDance();
	void OnRep_CurrentCharacterState();
	void OnRep_CurrentHealth();
	void OnRep_CurrentHunger();
	void OnRep_CurrentStamina();
	void OnRep_CurrentThirst();
	void OpenCodeLockUI(bool SetCode, class AActor* Lock);
	void OpenEquipmentMenu(class UBP_EquipmentInventory_C* EquipmentInventory);
	void OpenExtCookingMenu(class UBP_MasterInventory_C* Param_Inventory);
	void OpenExtCraftingMenu(class UBP_MasterInventory_C* Param_Inventory);
	void OpenInventory();
	void OpenInvMenu(class UBP_MasterInventory_C* Param_Inventory);
	void OpenVenderMenu(class UBP_MasterInventory_C* Param_Inventory);
	void ParentInventoryCheck(class UBP_MasterInventory_C* AddInventory, class UBP_MasterInventory_C* ContainerInventory, bool* AllowAdd);
	void PlayerDied__DelegateSignature(class AActor* Player, class APlayerController* Controller);
	void PlayerFindItemWithUseAmountLeft(TArray<class FName>& ItemIDs, bool* ItemFound, struct FS_InvSlot* ItemSlot);
	void PlayerFindKeyItem(class FName KeyCode, bool* Found);
	void PlayerFindNotFullUseAmountItems(TArray<class FName>& ItemIDs, bool* ItemFound, struct FS_InvSlot* ItemSlot);
	void PlayerInventoryFreeSlotCount(int32* FreeSlots);
	void PlayerInventoryTotalItemAmount(const struct FS_InvItem& InvItem, int32* TotalAmount);
	void PlayItemSound(class FName ItemId, E_Sounds SoundType);
	void QuickMove(class UBP_MasterInventory_C* Param_Inventory, int32 ItemIndex);
	void QuickSlotKeyBind(int32 QuickSlotIndex, struct FKey* SlotKey);
	void QuickSlotUseSelect(int32 QuickSlotIndex, bool InstantPlacement);
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void RechargeStaminaState();
	void RemoveAttachment(const struct FS_AttachmentSlotID& AttachmentID, const struct FS_InvSlotID& InvSlotID, bool DropItem, bool Rotated, bool SkipChecks, bool Swap, bool ShowNotifications);
	void RemoveBombVisual();
	void RemoveItemFromSlot(const struct FS_InvSlot& InvSlot, bool SpecialSlot);
	void RemoveQuickSlots(const struct FS_InvItem& EquipmentItem, class UBP_MasterInventory_C* Param_Inventory);
	bool RepairActorCheck(class UClass* RepairActor);
	bool RepairItem(const struct FS_InvItem& InvItem, struct FS_InvItem* RepairedInvItem);
	void RepairItemInSlot(const struct FS_InvSlotID& InvSlotID);
	void ResetStats();
	void ReturnStateValue(E_CharacterState CharacterState, TArray<struct FS_StatReduction>& Array, double* Value);
	void RotateMoveWidget__DelegateSignature();
	void SaveComponentData(class UBP_SGKSaveGame_C* SaveGame);
	void SearchEnemyTrace();
	void SearchForWeaponMag(class UClass* Weapon, bool* MagFound, struct FS_InvSlot* ItemSlot);
	void SearchPlayerInventoryForItem(class FName Item, int32 Amount, bool Param_RemoveItem, bool* ItemsFound, struct FS_InvSlot* InvSlots, TArray<struct FS_InvSlot>* AllInvSlots);
	void SearchPlayerInventoryForMultiItems(TArray<class FName>& Item, int32 Amount, bool Param_RemoveItem, bool IsForReload_, bool* ItemFound, struct FS_InvSlot* InvSlots, bool* ForReload_);
	void SelectedContextEntry(E_WorldActions* ActionType);
	void ServerAddAllQuickSlots();
	void ServerAddAttachmentFromSlot(const struct FS_InvSlotID& AttachmentItemID, class UBP_WeaponInventory_C* WeaponInventory);
	void ServerBuyVenderItem(const struct FS_VendorBuy& VenderBuyListing, int32 Amount);
	void ServerChamberWeapon();
	void ServerCheckCode(const class FText& Code, class AActor* Actor);
	void ServerCreateNewCraftingListing(class UBP_MasterInventory_C* CraftingInventory, class FName CraftingRecipeRow, int32 Amount);
	void ServerDestroyAttachment();
	void ServerDropItemFromSlot(const struct FS_InvSlotID& SlotID, E_SpecialSlotType SpecialType, bool Split);
	void ServerEmptyTargetInventory(class UBP_MasterInventory_C* StartInventory, class UBP_MasterInventory_C* TargetInventory);
	void ServerEndChamber(class UAnimMontage* Montage, class UAnimMontage* FPMontage);
	void ServerEndInteraction();
	void ServerEndMontage(class UAnimMontage* Montage, class UAnimMontage* FPMontage);
	void ServerEquipItemFromSlot(const struct FS_InvSlotID& SlotID, const struct FS_EquipmentSlotID& EquipmentSlotID);
	void ServerEquipWeaponFromSlot(const struct FS_InvSlotID& Slot_ID, const struct FS_WeaponSlotID& Weapon_Slot_ID);
	void ServerFinishHoldingNewItem();
	void ServerFinishInGameLoad();
	void ServerInteract(const struct FVector& TraceStart, const struct FVector& TraceEnd, E_WorldActions ActionType);
	void ServerKillPlayerCharacter(bool IsMelee, bool IsKnife, int32 MeleeAnim);
	void ServerLoadEquipmentPanels();
	void ServerLoadGame(const class FString& SlotName, const class FString& Level);
	void ServerMoveItem(const struct FS_InvSlotID& StartSlotID, const struct FS_InvSlotID& EndSlotID, bool Rotated, bool Split, E_SpecialSlotType SpecialType);
	void ServerOpenContainerWindow(class UBP_MasterInventory_C* Param_Inventory, bool Param_ToggleInventory);
	void ServerOpenExtCookingMenu(class UBP_MasterInventory_C* CookingInventory);
	void ServerOpenExtCraftingMenu(class UBP_MasterInventory_C* CraftingInventory);
	void ServerOpenExtEquipmentInv(class UBP_EquipmentInventory_C* EquipmentInventory);
	void ServerOpenExtInv(class UBP_MasterInventory_C* Inv);
	void ServerOpenItemContainerWindow(class UBP_MasterInventory_C* Param_Inventory, int32 Param_Index, bool Toggle_Inventory);
	void ServerOpenItemWeaponWindow(class UBP_MasterInventory_C* Param_Inventory, int32 Param_Index, bool Param_ToggleInventory);
	void ServerOpenLockpad(bool SetCode, class AActor* Lock);
	void ServerOpenVenderMenu(class UBP_MasterInventory_C* VenderInventory);
	void ServerOpenWeaponWindow(class UBP_MasterInventory_C* Param_Inventory, bool Param_ToggleInventory);
	void ServerPlayerInventoryRespawned();
	void ServerPlayMontage(class UAnimMontage* Montage, class UAnimMontage* FPMontage);
	void ServerPrimaryAction(bool KeyDown);
	void ServerQuickMoveItem(class UBP_MasterInventory_C* Param_Inventory, int32 ItemIndex);
	void ServerRemoveAttachment();
	void ServerRemoveUsingPlayer(class UBP_MasterInventory_C* Param_Inventory);
	void ServerRemoveWeaponAttachment(const struct FS_AttachmentSlotID& AttachmentID, const struct FS_InvSlotID& EndSlotID, bool DropItem, bool Rotated);
	void ServerRepairItem(const struct FS_InvSlotID& InvSlotID);
	void ServerResetRespawn();
	void ServerRespawnPlayer(bool Random);
	void ServerSaveGame(const class FString& SlotName);
	void ServerSecondaryAction(bool KeyDown);
	void ServerSellVenderItem(const struct FS_VendorSell& VenderSellItem, int32 Amount);
	void ServerSetBuildMode(bool Param_BuildMode);
	void ServerSetCode(const class FText& Code, class AActor* Actor);
	void ServerSetIgnoreActor(class AActor* Actor, double Time);
	void ServerSetInventoryOpen(bool Param_InventoryOpen);
	void ServerSplitStack(const struct FS_InvSlotID& InvSlotID);
	void ServerSprintKey(bool Down);
	void ServerSwapAttachmentItems(const struct FS_AttachmentSlotID& AttachmentID, class UBP_WeaponInventory_C* WeaponInventory);
	void ServerSwapEquipmentItems(const struct FS_EquipmentSlotID& StartEquipmentSlotID, const struct FS_EquipmentSlotID& EndEquipmentSlotID);
	void ServerSwapWeaponItems(const struct FS_WeaponSlotID& StartWeaponSlotID, const struct FS_WeaponSlotID& EndWeaponSlotID);
	void ServerToggleComponentInteractedActor();
	void ServerToggleFireMode();
	void ServerToggleMeleeCollision(bool TraceOn);
	void ServerUIFinishedCreating(class UBP_MasterInventory_C* Param_Inventory);
	void ServerUnequipItem(const struct FS_InvSlotID& EndInvSlotID, const struct FS_EquipmentSlotID& EquipmentSlotID, bool DropItem, bool Rotated, bool DestroyItem);
	void ServerUnequipWeapon(const struct FS_InvSlotID& EndInvSlotID, const struct FS_WeaponSlotID& WeaponSlotID, bool DropItem, bool Rotated, bool Destroy);
	void ServerUpdateClientEquipmentSlot(E_EquipmentType EquipmentSlot);
	void ServerUpdateClientWeaponSlot(E_WeaponSlots WeaponSlot);
	void ServerUpdateItemQuickSlot(const struct FS_InvSlotID& Slot_ID, int32 QuickSlotIndex);
	void ServerUpdateRespawnPointName(const class FText& Param_Name);
	void ServerUpdateState(E_CharacterState CharacterState);
	void ServerUpdateWeaponQuickSlot(const struct FS_WeaponSlotID& Weapon_Slot_ID, int32 QuickSlotIndex);
	void ServerUseItemAction(const struct FS_InvSlotID& InvSlotID, E_InventoryActions Action, bool InstantPlacement);
	void ServerUseWeaponAction(const struct FS_WeaponSlotID& WeaponSlotID, E_InventoryActions Action);
	void SetHoldableMulticast(const struct FS_WeaponSlot& Param_HoldingWeaponSlot);
	void SetHoldableServer(const struct FS_WeaponSlot& Param_HoldingWeaponSlot);
	void SetInstigatorServer(class AActor* Param_EnemyInstigator);
	void SetInvSlots(const struct FS_InvSlot& InvSlots, int32 Height, int32 Width, bool Rotated, TArray<struct FS_InvSlot>* UpdatedSlots);
	void SGK__Fix__default_values_being_lost();
	void SGK_AllowStartingItems(bool* AllowStartingItems);
	void SGK_ItemSound(class FName ItemId, E_Sounds SoundType);
	void SGK_RemoveAdditionalChecks(const struct FS_InvSlot& InvSlot);
	void ShowNewAttachment();
	void SpawnDroppedItem(const struct FS_InvItem& InvItem);
	void SpawnMainHand();
	void SplitStack(const struct FS_InvSlotID& InvSlotID);
	void SprintCheck();
	void StaminaStateCheck(E_CharacterState State, double Min_Stamina, bool* CanUseState);
	void StartBleedDamage(int32 TickDamage, double TickTime, double BleedLength);
	void StarvationState();
	void StateTimer();
	bool SwapAttachments(const struct FS_AttachmentSlotID& AttachmentID, class UBP_WeaponInventory_C* WeaponInventory, bool CheckOnly);
	void SwapEquipmentSlots(const struct FS_EquipmentSlotID& StartEquipmentSlotID, const struct FS_EquipmentSlotID& EndEquipmentSlotID);
	void SwapWeaponSlots(const struct FS_WeaponSlotID& StartWeaponSlotID, const struct FS_WeaponSlotID& EndWeaponSlotID);
	void TakeDamage(int32 Damage, E_DamageType DamageType, E_Hitbox HitBox);
	void ThirstState();
	void ToggleBuildPartNameUI(bool Open);
	void ToggleCodeLockUI();
	void ToggleInventory();
	void Tools1Counter();
	void Tools2Counter();
	void UnequipItem(const struct FS_InvSlotID& EndSlotID, const struct FS_EquipmentSlotID& EquipmentSlotID, bool DropItem, bool Rotated, bool DestroyItem);
	void UnequipWeapon(const struct FS_InvSlotID& EndInvSlotID, const struct FS_WeaponSlotID& WeaponSlotID, bool DropItem, bool Rotated, bool Destroy);
	void UnHoldItem(bool Force);
	void UpdateDetails(const struct FS_ContainerDetails& Param_InventoryDetails, class UBP_MasterInventory_C* Param_Inventory);
	void UpdateEquipmentSlotWidget(const struct FS_EquipmentSlot& EquipmentSlot);
	void UpdateItemQuickSlot(const struct FS_InvSlotID& Slot_ID, int32 QuickSlotIndex);
	void UpdateItemUseAmount(struct FS_InvItem& Item, int32 Change_Amount, bool* ItemEmpty, struct FS_InvItem* ItemOut);
	void UpdateMaxMovementSpeed(E_CharacterState CharacterState);
	void UpdateQuickSlotItem(const struct FS_InvSlotID& InvSlotID, int32 QuickSlot);
	void UpdateQuickSlotWeapon(const struct FS_WeaponSlotID& WeaponSlotID, int32 QuickSlot);
	void UpdateWeaponQuickSlot(const struct FS_WeaponSlotID& Weapon_Slot_ID, int32 QuickSlotIndex);
	void UpdateWeaponSlotWidget(const struct FS_WeaponSlot& WeaponSlot);
	void UseInventoryAction(const struct FS_InvSlot& InvSlot, E_InventoryActions Action, bool InstantPlacement);
	void UseItemFromSlot(const struct FS_InvSlotID& InvSlotID, E_InventoryActions Action, bool InstantPlacement);
	void UseStaminaState();
	void UseWeaponFromSlot(const struct FS_WeaponSlotID& WeaponSlotID, E_InventoryActions Action);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PlayerInventory_C">();
	}
	static class UBP_PlayerInventory_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_PlayerInventory_C>();
	}
};
static_assert(alignof(UBP_PlayerInventory_C) == 0x000008, "Wrong alignment on UBP_PlayerInventory_C");
static_assert(sizeof(UBP_PlayerInventory_C) == 0x0010B0, "Wrong size on UBP_PlayerInventory_C");
static_assert(offsetof(UBP_PlayerInventory_C, UberGraphFrame_BP_PlayerInventory_C) == 0x0006C8, "Member 'UBP_PlayerInventory_C::UberGraphFrame_BP_PlayerInventory_C' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentCamera) == 0x0006D0, "Member 'UBP_PlayerInventory_C::CurrentCamera' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ClientInteractHitResult) == 0x0006D8, "Member 'UBP_PlayerInventory_C::ClientInteractHitResult' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ExtCookingComponent) == 0x0007C0, "Member 'UBP_PlayerInventory_C::ExtCookingComponent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewAttachmentWeaponInventory) == 0x0007C8, "Member 'UBP_PlayerInventory_C::NewAttachmentWeaponInventory' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ExtCraftingComponent) == 0x0007D0, "Member 'UBP_PlayerInventory_C::ExtCraftingComponent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CharacterComponent) == 0x0007D8, "Member 'UBP_PlayerInventory_C::CharacterComponent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerBuildingComponent) == 0x0007E0, "Member 'UBP_PlayerInventory_C::PlayerBuildingComponent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DisableCharMovement) == 0x0007E8, "Member 'UBP_PlayerInventory_C::DisableCharMovement' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, VenderComponent) == 0x0007F0, "Member 'UBP_PlayerInventory_C::VenderComponent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ExtInventoryComponent) == 0x0007F8, "Member 'UBP_PlayerInventory_C::ExtInventoryComponent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InventoryOpen) == 0x000800, "Member 'UBP_PlayerInventory_C::InventoryOpen' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InteractedActor) == 0x000808, "Member 'UBP_PlayerInventory_C::InteractedActor' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentHealth) == 0x000810, "Member 'UBP_PlayerInventory_C::CurrentHealth' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentHunger) == 0x000818, "Member 'UBP_PlayerInventory_C::CurrentHunger' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentThirst) == 0x000820, "Member 'UBP_PlayerInventory_C::CurrentThirst' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentStamina) == 0x000828, "Member 'UBP_PlayerInventory_C::CurrentStamina' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentCharacterState) == 0x000830, "Member 'UBP_PlayerInventory_C::CurrentCharacterState' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, IsMoving) == 0x000831, "Member 'UBP_PlayerInventory_C::IsMoving' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, SprintKeyDown) == 0x000832, "Member 'UBP_PlayerInventory_C::SprintKeyDown' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseStaminaTimer) == 0x000838, "Member 'UBP_PlayerInventory_C::UseStaminaTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RechargeStaminaTimer) == 0x000840, "Member 'UBP_PlayerInventory_C::RechargeStaminaTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, BlockInput) == 0x000848, "Member 'UBP_PlayerInventory_C::BlockInput' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StarvationTimer) == 0x000850, "Member 'UBP_PlayerInventory_C::StarvationTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DehydrationTimer) == 0x000858, "Member 'UBP_PlayerInventory_C::DehydrationTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewHoldingItem) == 0x000860, "Member 'UBP_PlayerInventory_C::NewHoldingItem' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, SGKCharacter) == 0x000868, "Member 'UBP_PlayerInventory_C::SGKCharacter' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, HoldingInvSlot) == 0x000870, "Member 'UBP_PlayerInventory_C::HoldingInvSlot' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewHoldingInvSlot) == 0x0008C0, "Member 'UBP_PlayerInventory_C::NewHoldingInvSlot' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewHoldingWeaponSlot) == 0x000910, "Member 'UBP_PlayerInventory_C::NewHoldingWeaponSlot' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentHoldingType) == 0x000960, "Member 'UBP_PlayerInventory_C::CurrentHoldingType' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewHoldingType) == 0x000961, "Member 'UBP_PlayerInventory_C::NewHoldingType' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InAttack) == 0x000962, "Member 'UBP_PlayerInventory_C::InAttack' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, IsSplitKeyDown) == 0x000963, "Member 'UBP_PlayerInventory_C::IsSplitKeyDown' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, HoldingWeaponSlot) == 0x000968, "Member 'UBP_PlayerInventory_C::HoldingWeaponSlot' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, Equipping) == 0x0009B8, "Member 'UBP_PlayerInventory_C::Equipping' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RemoveAttachmentSlot) == 0x0009C0, "Member 'UBP_PlayerInventory_C::RemoveAttachmentSlot' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DropRemoveAttachent) == 0x000A08, "Member 'UBP_PlayerInventory_C::DropRemoveAttachent' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RemoveSlotTarget) == 0x000A10, "Member 'UBP_PlayerInventory_C::RemoveSlotTarget' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RotatedAttachTarget) == 0x000A20, "Member 'UBP_PlayerInventory_C::RotatedAttachTarget' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewAttachmentID) == 0x000A28, "Member 'UBP_PlayerInventory_C::NewAttachmentID' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, NewAttachment) == 0x000A38, "Member 'UBP_PlayerInventory_C::NewAttachment' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeathController) == 0x000A40, "Member 'UBP_PlayerInventory_C::DeathController' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, SwapAttachment) == 0x000A48, "Member 'UBP_PlayerInventory_C::SwapAttachment' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, AttachingItem) == 0x000A50, "Member 'UBP_PlayerInventory_C::AttachingItem' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RespawnedCharacter) == 0x000A80, "Member 'UBP_PlayerInventory_C::RespawnedCharacter' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeadBodyTimer) == 0x000A88, "Member 'UBP_PlayerInventory_C::DeadBodyTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerName) == 0x000A90, "Member 'UBP_PlayerInventory_C::PlayerName' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeadCharacter) == 0x000AA8, "Member 'UBP_PlayerInventory_C::DeadCharacter' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CraftingRecipes) == 0x000AB0, "Member 'UBP_PlayerInventory_C::CraftingRecipes' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, Respawned) == 0x000AC0, "Member 'UBP_PlayerInventory_C::Respawned' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeadCharacterClass) == 0x000AC8, "Member 'UBP_PlayerInventory_C::DeadCharacterClass' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, SprintCheckTimer) == 0x000AD0, "Member 'UBP_PlayerInventory_C::SprintCheckTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ServerHitResult) == 0x000AD8, "Member 'UBP_PlayerInventory_C::ServerHitResult' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, BuildMode) == 0x000BC0, "Member 'UBP_PlayerInventory_C::BuildMode' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, Bleeding) == 0x000BC1, "Member 'UBP_PlayerInventory_C::Bleeding' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UIOpen) == 0x000BC2, "Member 'UBP_PlayerInventory_C::UIOpen' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, Tick_Damage) == 0x000BC4, "Member 'UBP_PlayerInventory_C::Tick_Damage' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, QuickMoveKeyDown) == 0x000BC8, "Member 'UBP_PlayerInventory_C::QuickMoveKeyDown' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, BleedDamageTimer) == 0x000BD0, "Member 'UBP_PlayerInventory_C::BleedDamageTimer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RespawnHUD) == 0x000BD8, "Member 'UBP_PlayerInventory_C::RespawnHUD' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RespawnPointName) == 0x000BE0, "Member 'UBP_PlayerInventory_C::RespawnPointName' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CameraLean) == 0x000BF8, "Member 'UBP_PlayerInventory_C::CameraLean' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CharacterLean) == 0x000C00, "Member 'UBP_PlayerInventory_C::CharacterLean' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerHUD) == 0x000C08, "Member 'UBP_PlayerInventory_C::PlayerHUD' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CurrentSpringArm) == 0x000C10, "Member 'UBP_PlayerInventory_C::CurrentSpringArm' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InteractionDistance) == 0x000C18, "Member 'UBP_PlayerInventory_C::InteractionDistance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InteractionTraceChannel) == 0x000C20, "Member 'UBP_PlayerInventory_C::InteractionTraceChannel' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, QuickSlots) == 0x000C24, "Member 'UBP_PlayerInventory_C::QuickSlots' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MaxQuickSlots) == 0x000C28, "Member 'UBP_PlayerInventory_C::MaxQuickSlots' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MaxHealth) == 0x000C2C, "Member 'UBP_PlayerInventory_C::MaxHealth' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StartingHealth) == 0x000C30, "Member 'UBP_PlayerInventory_C::StartingHealth' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MaxStamina) == 0x000C38, "Member 'UBP_PlayerInventory_C::MaxStamina' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StartingStamina) == 0x000C40, "Member 'UBP_PlayerInventory_C::StartingStamina' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StaminaReduction) == 0x000C48, "Member 'UBP_PlayerInventory_C::StaminaReduction' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StaminaReductionTime) == 0x000C98, "Member 'UBP_PlayerInventory_C::StaminaReductionTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StaminaRecharge) == 0x000CE8, "Member 'UBP_PlayerInventory_C::StaminaRecharge' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StaminaMovementStates) == 0x000D38, "Member 'UBP_PlayerInventory_C::StaminaMovementStates' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseThirst) == 0x000D88, "Member 'UBP_PlayerInventory_C::UseThirst' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ThirstReduction) == 0x000D90, "Member 'UBP_PlayerInventory_C::ThirstReduction' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MaxThirst) == 0x000DA0, "Member 'UBP_PlayerInventory_C::MaxThirst' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StartingThirst) == 0x000DA8, "Member 'UBP_PlayerInventory_C::StartingThirst' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ThirstReductionTime) == 0x000DB0, "Member 'UBP_PlayerInventory_C::ThirstReductionTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DehydrationDamage) == 0x000DB8, "Member 'UBP_PlayerInventory_C::DehydrationDamage' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DehydrationDamageTime) == 0x000DC0, "Member 'UBP_PlayerInventory_C::DehydrationDamageTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseHunger) == 0x000DC8, "Member 'UBP_PlayerInventory_C::UseHunger' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, HungerReduction) == 0x000DD0, "Member 'UBP_PlayerInventory_C::HungerReduction' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MaxHunger) == 0x000DE0, "Member 'UBP_PlayerInventory_C::MaxHunger' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StartingHunger) == 0x000DE8, "Member 'UBP_PlayerInventory_C::StartingHunger' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StarvationDamageTime) == 0x000DF0, "Member 'UBP_PlayerInventory_C::StarvationDamageTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StarvationDamage) == 0x000DF8, "Member 'UBP_PlayerInventory_C::StarvationDamage' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, HungerReductionTime) == 0x000E00, "Member 'UBP_PlayerInventory_C::HungerReductionTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MovementSpeeds) == 0x000E08, "Member 'UBP_PlayerInventory_C::MovementSpeeds' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RotateMoveWidget) == 0x000E58, "Member 'UBP_PlayerInventory_C::RotateMoveWidget' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InventoryToggled) == 0x000E68, "Member 'UBP_PlayerInventory_C::InventoryToggled' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InventorySlotSize) == 0x000E78, "Member 'UBP_PlayerInventory_C::InventorySlotSize' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, AllowDroppingHeldItem) == 0x000E88, "Member 'UBP_PlayerInventory_C::AllowDroppingHeldItem' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseNotificationSounds) == 0x000E89, "Member 'UBP_PlayerInventory_C::UseNotificationSounds' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, WarningNotifySound) == 0x000E90, "Member 'UBP_PlayerInventory_C::WarningNotifySound' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ClearInventoryOnDeath) == 0x000E98, "Member 'UBP_PlayerInventory_C::ClearInventoryOnDeath' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeathSound) == 0x000EA0, "Member 'UBP_PlayerInventory_C::DeathSound' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ClearLearnRecipesOnDeath) == 0x000EA8, "Member 'UBP_PlayerInventory_C::ClearLearnRecipesOnDeath' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeletePlayerSaveOnDeath) == 0x000EA9, "Member 'UBP_PlayerInventory_C::DeletePlayerSaveOnDeath' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DeadBodyDespawnTime) == 0x000EB0, "Member 'UBP_PlayerInventory_C::DeadBodyDespawnTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, InteractionTraceDebug) == 0x000EB8, "Member 'UBP_PlayerInventory_C::InteractionTraceDebug' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, TakeDamageSound) == 0x000EC0, "Member 'UBP_PlayerInventory_C::TakeDamageSound' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseHealthRegeneration) == 0x000EC8, "Member 'UBP_PlayerInventory_C::UseHealthRegeneration' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, HealthRegenerationTickAmount) == 0x000ECC, "Member 'UBP_PlayerInventory_C::HealthRegenerationTickAmount' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MinHealthRegenerationHunger) == 0x000ED0, "Member 'UBP_PlayerInventory_C::MinHealthRegenerationHunger' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, MinHealthRegenerationThirst) == 0x000ED8, "Member 'UBP_PlayerInventory_C::MinHealthRegenerationThirst' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RegenerationTickTime) == 0x000EE0, "Member 'UBP_PlayerInventory_C::RegenerationTickTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseFallDamage) == 0x000EE8, "Member 'UBP_PlayerInventory_C::UseFallDamage' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, FallDamage) == 0x000EF0, "Member 'UBP_PlayerInventory_C::FallDamage' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StartFallDamageTime) == 0x000EF8, "Member 'UBP_PlayerInventory_C::StartFallDamageTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, FallDamageIncreeseTime) == 0x000F00, "Member 'UBP_PlayerInventory_C::FallDamageIncreeseTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, FallDamageVelocity) == 0x000F08, "Member 'UBP_PlayerInventory_C::FallDamageVelocity' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ResourceHarvestAmount) == 0x000F10, "Member 'UBP_PlayerInventory_C::ResourceHarvestAmount' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseLearnableRecipes) == 0x000F14, "Member 'UBP_PlayerInventory_C::UseLearnableRecipes' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StartingCraftingRecipes) == 0x000F18, "Member 'UBP_PlayerInventory_C::StartingCraftingRecipes' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DefaultStance) == 0x000F28, "Member 'UBP_PlayerInventory_C::DefaultStance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, AllowStanceChange) == 0x000F29, "Member 'UBP_PlayerInventory_C::AllowStanceChange' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, AllowLeaningInCombatStance) == 0x000F2A, "Member 'UBP_PlayerInventory_C::AllowLeaningInCombatStance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, AllowLeaningInStandardStance) == 0x000F2B, "Member 'UBP_PlayerInventory_C::AllowLeaningInStandardStance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, ThirdPersonCameraOffset) == 0x000F30, "Member 'UBP_PlayerInventory_C::ThirdPersonCameraOffset' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RepairActorRange) == 0x000F38, "Member 'UBP_PlayerInventory_C::RepairActorRange' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, StaminaRechargeTime) == 0x000F40, "Member 'UBP_PlayerInventory_C::StaminaRechargeTime' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, AllowInteractionWhileInAction) == 0x000F90, "Member 'UBP_PlayerInventory_C::AllowInteractionWhileInAction' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, DebugInteractionTrace) == 0x000F91, "Member 'UBP_PlayerInventory_C::DebugInteractionTrace' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, IgnoreInteractActor) == 0x000F98, "Member 'UBP_PlayerInventory_C::IgnoreInteractActor' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, LastCharacterRotation) == 0x000FA0, "Member 'UBP_PlayerInventory_C::LastCharacterRotation' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, LastCharacterLocation) == 0x000FB8, "Member 'UBP_PlayerInventory_C::LastCharacterLocation' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, UseLearnableExternalRecipes) == 0x000FD0, "Member 'UBP_PlayerInventory_C::UseLearnableExternalRecipes' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, CloseInventorySound) == 0x000FD8, "Member 'UBP_PlayerInventory_C::CloseInventorySound' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, OpenInventorySound) == 0x000FE0, "Member 'UBP_PlayerInventory_C::OpenInventorySound' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, SaveFound) == 0x000FE8, "Member 'UBP_PlayerInventory_C::SaveFound' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerCraftingType) == 0x000FE9, "Member 'UBP_PlayerInventory_C::PlayerCraftingType' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerInventoryDetails) == 0x000FF0, "Member 'UBP_PlayerInventory_C::PlayerInventoryDetails' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, SearchEnemyDistance) == 0x001060, "Member 'UBP_PlayerInventory_C::SearchEnemyDistance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, EnemyInstigator) == 0x001068, "Member 'UBP_PlayerInventory_C::EnemyInstigator' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerTeam) == 0x001070, "Member 'UBP_PlayerInventory_C::PlayerTeam' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, PlayerDied) == 0x001078, "Member 'UBP_PlayerInventory_C::PlayerDied' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, BQuickSlotL) == 0x001088, "Member 'UBP_PlayerInventory_C::BQuickSlotL' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, bVictoryDance) == 0x001090, "Member 'UBP_PlayerInventory_C::bVictoryDance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, RandomDance) == 0x001098, "Member 'UBP_PlayerInventory_C::RandomDance' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, Greande1Amount) == 0x0010A8, "Member 'UBP_PlayerInventory_C::Greande1Amount' has a wrong offset!");
static_assert(offsetof(UBP_PlayerInventory_C, Grenade2Amount) == 0x0010AC, "Member 'UBP_PlayerInventory_C::Grenade2Amount' has a wrong offset!");

}

