#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MinimapPlugin

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "MinimapPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class MinimapPlugin.MapRevealerComponent
// 0x0020 (0x05A0 - 0x0580)
class UMapRevealerComponent final : public UBoxComponent
{
public:
	class UMaterialInterface*                     RevealMaterial;                                    // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapFogRevealMode                             RevealMode;                                        // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FD[0x3];                                     // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RevealDropOffDistance;                             // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTempEngineBugWorkaround;                          // 0x0588(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FE[0x7];                                     // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               RevealMaterialInstance;                            // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FF[0x8];                                     // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRevealDropOffDistance(const float NewRevealDropOffDistance);
	void SetRevealExtent(const float NewRevealExtentX, const float NewRevealExtentY);
	void SetRevealMode(const EMapFogRevealMode NewRevealMode);

	float GetRevealDropOffDistance() const;
	void GetRevealExtent(float* RevealExtentX, float* RevealExtentY) const;
	EMapFogRevealMode GetRevealMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRevealerComponent">();
	}
	static class UMapRevealerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRevealerComponent>();
	}
};
static_assert(alignof(UMapRevealerComponent) == 0x000010, "Wrong alignment on UMapRevealerComponent");
static_assert(sizeof(UMapRevealerComponent) == 0x0005A0, "Wrong size on UMapRevealerComponent");
static_assert(offsetof(UMapRevealerComponent, RevealMaterial) == 0x000578, "Member 'UMapRevealerComponent::RevealMaterial' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, RevealMode) == 0x000580, "Member 'UMapRevealerComponent::RevealMode' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, RevealDropOffDistance) == 0x000584, "Member 'UMapRevealerComponent::RevealDropOffDistance' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, bTempEngineBugWorkaround) == 0x000588, "Member 'UMapRevealerComponent::bTempEngineBugWorkaround' has a wrong offset!");
static_assert(offsetof(UMapRevealerComponent, RevealMaterialInstance) == 0x000590, "Member 'UMapRevealerComponent::RevealMaterialInstance' has a wrong offset!");

// Class MinimapPlugin.MapAreaPrimitiveComponent
// 0x0010 (0x0550 - 0x0540)
class UMapAreaPrimitiveComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_2500[0x18];                                    // 0x0538(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaPrimitiveComponent">();
	}
	static class UMapAreaPrimitiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapAreaPrimitiveComponent>();
	}
};
static_assert(alignof(UMapAreaPrimitiveComponent) == 0x000010, "Wrong alignment on UMapAreaPrimitiveComponent");
static_assert(sizeof(UMapAreaPrimitiveComponent) == 0x000550, "Wrong size on UMapAreaPrimitiveComponent");

// Class MinimapPlugin.MapAreaBase
// 0x0018 (0x02A8 - 0x0290)
class AMapAreaBase : public AActor
{
public:
	class UBoxComponent*                          AreaBounds;                                        // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapAreaPrimitiveComponent*             AreaPrimitive;                                     // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapViewComponent*                      AreaMapView;                                       // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetMapViewCornerUVs(class UMapViewComponent* MapView, TArray<struct FVector2D>* CornerUVs);

	class UBoxComponent* GetAreaBounds() const;
	int32 GetLevelAtHeight(const float WorldZ) const;
	float GetMapAspectRatio() const;
	class UMapViewComponent* GetMapView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaBase">();
	}
	static class AMapAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapAreaBase>();
	}
};
static_assert(alignof(AMapAreaBase) == 0x000008, "Wrong alignment on AMapAreaBase");
static_assert(sizeof(AMapAreaBase) == 0x0002A8, "Wrong size on AMapAreaBase");
static_assert(offsetof(AMapAreaBase, AreaBounds) == 0x000290, "Member 'AMapAreaBase::AreaBounds' has a wrong offset!");
static_assert(offsetof(AMapAreaBase, AreaPrimitive) == 0x000298, "Member 'AMapAreaBase::AreaPrimitive' has a wrong offset!");
static_assert(offsetof(AMapAreaBase, AreaMapView) == 0x0002A0, "Member 'AMapAreaBase::AreaMapView' has a wrong offset!");

// Class MinimapPlugin.MapBackground
// 0x0120 (0x03C8 - 0x02A8)
class AMapBackground final : public AMapAreaBase
{
public:
	FMulticastInlineDelegateProperty_             OnMapBackgroundTextureChanged;                     // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundMaterialChanged;                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundAppearanceChanged;                  // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundRendered;                           // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundOverlayChanged;                     // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FMapBackgroundLevel>            BackgroundLevels;                                  // 0x02F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BackgroundMaterial_UMG;                            // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BackgroundMaterial_Canvas;                         // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackgroundVisible;                                // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2502[0x3];                                     // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BackgroundPriority;                                // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BackgroundZOrder;                                  // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DynamicRenderTargetSize;                           // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             HiddenActorClasses;                                // 0x0328(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         HiddenActors;                                      // 0x0338(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRenderNavigationMesh;                             // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2503[0x7];                                     // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> MaterialInstances;                                 // 0x0350(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UBoxComponent*>                  LevelVisualizers;                                  // 0x03A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2504[0x8];                                     // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCaptureComponent2D*               CaptureComponent2D;                                // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMeshRenderingComponent*             NavMeshRenderingComponent;                         // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UMaterialInstanceDynamic* GetBackgroundMaterialInstanceForCanvas(class UMapRendererComponent* Renderer);
	void RerenderBackground();
	void SetBackgroundMaterialForCanvas(class UMaterialInterface* NewMaterial);
	void SetBackgroundMaterialForUMG(class UMaterialInterface* NewMaterial);
	void SetBackgroundOverlay(const int32 Level, class UTextureRenderTarget2D* NewBackgroundOverlay);
	void SetBackgroundPriority(const int32 NewBackgroundPriority);
	void SetBackgroundTexture(const int32 Level, class UTexture2D* NewBackgroundTexture);
	void SetBackgroundVisible(const bool bNewVisible);
	void SetBackgroundZOrder(const int32 NewBackgroundZOrder);

	class UMaterialInterface* GetBackgroundMaterialForUMG() const;
	class UTextureRenderTarget2D* GetBackgroundOverlay(const int32 Level) const;
	int32 GetBackgroundPriority() const;
	class UTexture* GetBackgroundTexture(const int32 Level) const;
	class UTexture* GetBackgroundTextureAtHeight(const float WorldZ) const;
	int32 GetBackgroundZOrder() const;
	bool IsBackgroundVisible() const;
	bool IsMultiLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapBackground">();
	}
	static class AMapBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapBackground>();
	}
};
static_assert(alignof(AMapBackground) == 0x000008, "Wrong alignment on AMapBackground");
static_assert(sizeof(AMapBackground) == 0x0003C8, "Wrong size on AMapBackground");
static_assert(offsetof(AMapBackground, OnMapBackgroundTextureChanged) == 0x0002A8, "Member 'AMapBackground::OnMapBackgroundTextureChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundMaterialChanged) == 0x0002B8, "Member 'AMapBackground::OnMapBackgroundMaterialChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundAppearanceChanged) == 0x0002C8, "Member 'AMapBackground::OnMapBackgroundAppearanceChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundRendered) == 0x0002D8, "Member 'AMapBackground::OnMapBackgroundRendered' has a wrong offset!");
static_assert(offsetof(AMapBackground, OnMapBackgroundOverlayChanged) == 0x0002E8, "Member 'AMapBackground::OnMapBackgroundOverlayChanged' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundLevels) == 0x0002F8, "Member 'AMapBackground::BackgroundLevels' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundMaterial_UMG) == 0x000308, "Member 'AMapBackground::BackgroundMaterial_UMG' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundMaterial_Canvas) == 0x000310, "Member 'AMapBackground::BackgroundMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(AMapBackground, bBackgroundVisible) == 0x000318, "Member 'AMapBackground::bBackgroundVisible' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundPriority) == 0x00031C, "Member 'AMapBackground::BackgroundPriority' has a wrong offset!");
static_assert(offsetof(AMapBackground, BackgroundZOrder) == 0x000320, "Member 'AMapBackground::BackgroundZOrder' has a wrong offset!");
static_assert(offsetof(AMapBackground, DynamicRenderTargetSize) == 0x000324, "Member 'AMapBackground::DynamicRenderTargetSize' has a wrong offset!");
static_assert(offsetof(AMapBackground, HiddenActorClasses) == 0x000328, "Member 'AMapBackground::HiddenActorClasses' has a wrong offset!");
static_assert(offsetof(AMapBackground, HiddenActors) == 0x000338, "Member 'AMapBackground::HiddenActors' has a wrong offset!");
static_assert(offsetof(AMapBackground, bRenderNavigationMesh) == 0x000348, "Member 'AMapBackground::bRenderNavigationMesh' has a wrong offset!");
static_assert(offsetof(AMapBackground, MaterialInstances) == 0x000350, "Member 'AMapBackground::MaterialInstances' has a wrong offset!");
static_assert(offsetof(AMapBackground, LevelVisualizers) == 0x0003A0, "Member 'AMapBackground::LevelVisualizers' has a wrong offset!");
static_assert(offsetof(AMapBackground, CaptureComponent2D) == 0x0003B8, "Member 'AMapBackground::CaptureComponent2D' has a wrong offset!");
static_assert(offsetof(AMapBackground, NavMeshRenderingComponent) == 0x0003C0, "Member 'AMapBackground::NavMeshRenderingComponent' has a wrong offset!");

// Class MinimapPlugin.MapFog
// 0x0130 (0x03D8 - 0x02A8)
class AMapFog final : public AMapAreaBase
{
public:
	FMulticastInlineDelegateProperty_             OnMapFogMaterialChanged;                           // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         FogRenderTargetSize;                               // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250A[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FogMaterial_UMG;                                   // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FogMaterial_Canvas;                                // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOpacityHidden;                              // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOpacityExplored;                            // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOpacityRevealing;                           // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250B[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FogCombineMaterial;                                // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogCacheLifetime;                                  // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableWorldFog;                                   // 0x02EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250C[0x3];                                     // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FogPostProcessMaterial;                            // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOpacityHidden;                                // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOpacityExplored;                              // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOpacityRevealing;                             // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250D[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFogPostProcessVolumeOption                   AutoLocatePostProcessVolume;                       // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250E[0x7];                                     // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 PermanentRevealRT_A;                               // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 PermanentRevealRT_B;                               // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RevealRT_Staging;                                  // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250F[0x8];                                     // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> MaterialInstances;                                 // 0x0338(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FogCombineMatInst;                                 // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FogPostProcessMatInst;                             // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2510[0x30];                                    // 0x0398(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapRevealerComponent*>          MapRevealers;                                      // 0x03C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool GetFogAtLocation(const struct FVector& WorldLocation, const bool bRequireCurrentlyRevealing, float* RevealFactor);
	class UMaterialInterface* GetFogMaterialForUMG();
	class UMaterialInstanceDynamic* GetFogMaterialInstanceForCanvas(class UMapRendererComponent* Renderer);
	void OnMapRevealerRegistered(class UMapRevealerComponent* MapRevealer);
	void OnMapRevealerUnregistered(class UMapRevealerComponent* MapRevealer);
	void SetFogMaterialForCanvas(class UMaterialInterface* NewMaterial);
	void SetFogMaterialForUMG(class UMaterialInterface* NewMaterial);

	class UTextureRenderTarget2D* GetDestinationFogRenderTarget() const;
	class UTextureRenderTarget2D* GetSourceFogRenderTarget() const;
	float GetWorldToPixelRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapFog">();
	}
	static class AMapFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapFog>();
	}
};
static_assert(alignof(AMapFog) == 0x000008, "Wrong alignment on AMapFog");
static_assert(sizeof(AMapFog) == 0x0003D8, "Wrong size on AMapFog");
static_assert(offsetof(AMapFog, OnMapFogMaterialChanged) == 0x0002A8, "Member 'AMapFog::OnMapFogMaterialChanged' has a wrong offset!");
static_assert(offsetof(AMapFog, FogRenderTargetSize) == 0x0002B8, "Member 'AMapFog::FogRenderTargetSize' has a wrong offset!");
static_assert(offsetof(AMapFog, FogMaterial_UMG) == 0x0002C0, "Member 'AMapFog::FogMaterial_UMG' has a wrong offset!");
static_assert(offsetof(AMapFog, FogMaterial_Canvas) == 0x0002C8, "Member 'AMapFog::FogMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(AMapFog, MinimapOpacityHidden) == 0x0002D0, "Member 'AMapFog::MinimapOpacityHidden' has a wrong offset!");
static_assert(offsetof(AMapFog, MinimapOpacityExplored) == 0x0002D4, "Member 'AMapFog::MinimapOpacityExplored' has a wrong offset!");
static_assert(offsetof(AMapFog, MinimapOpacityRevealing) == 0x0002D8, "Member 'AMapFog::MinimapOpacityRevealing' has a wrong offset!");
static_assert(offsetof(AMapFog, FogCombineMaterial) == 0x0002E0, "Member 'AMapFog::FogCombineMaterial' has a wrong offset!");
static_assert(offsetof(AMapFog, FogCacheLifetime) == 0x0002E8, "Member 'AMapFog::FogCacheLifetime' has a wrong offset!");
static_assert(offsetof(AMapFog, bEnableWorldFog) == 0x0002EC, "Member 'AMapFog::bEnableWorldFog' has a wrong offset!");
static_assert(offsetof(AMapFog, FogPostProcessMaterial) == 0x0002F0, "Member 'AMapFog::FogPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(AMapFog, WorldOpacityHidden) == 0x0002F8, "Member 'AMapFog::WorldOpacityHidden' has a wrong offset!");
static_assert(offsetof(AMapFog, WorldOpacityExplored) == 0x0002FC, "Member 'AMapFog::WorldOpacityExplored' has a wrong offset!");
static_assert(offsetof(AMapFog, WorldOpacityRevealing) == 0x000300, "Member 'AMapFog::WorldOpacityRevealing' has a wrong offset!");
static_assert(offsetof(AMapFog, PostProcessVolume) == 0x000308, "Member 'AMapFog::PostProcessVolume' has a wrong offset!");
static_assert(offsetof(AMapFog, AutoLocatePostProcessVolume) == 0x000310, "Member 'AMapFog::AutoLocatePostProcessVolume' has a wrong offset!");
static_assert(offsetof(AMapFog, PermanentRevealRT_A) == 0x000318, "Member 'AMapFog::PermanentRevealRT_A' has a wrong offset!");
static_assert(offsetof(AMapFog, PermanentRevealRT_B) == 0x000320, "Member 'AMapFog::PermanentRevealRT_B' has a wrong offset!");
static_assert(offsetof(AMapFog, RevealRT_Staging) == 0x000328, "Member 'AMapFog::RevealRT_Staging' has a wrong offset!");
static_assert(offsetof(AMapFog, MaterialInstances) == 0x000338, "Member 'AMapFog::MaterialInstances' has a wrong offset!");
static_assert(offsetof(AMapFog, FogCombineMatInst) == 0x000388, "Member 'AMapFog::FogCombineMatInst' has a wrong offset!");
static_assert(offsetof(AMapFog, FogPostProcessMatInst) == 0x000390, "Member 'AMapFog::FogPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(AMapFog, MapRevealers) == 0x0003C8, "Member 'AMapFog::MapRevealers' has a wrong offset!");

// Class MinimapPlugin.MapFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMapFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMapIconComponent*> BoxSelectInView(const struct FVector2D& StartUV, const struct FVector2D& EndUV, class UMapViewComponent* MapView, const bool bIsCircular);
	static struct FVector2D ClampIntoView(const struct FVector2D& UV, const float OuterRadiusUV, const bool bIsCircular);
	static bool ComputeViewFrustum(const class UObject* WorldContextObject, class UMapViewComponent* MapView, const bool bIsCircular, TArray<struct FVector2D>* CornerUVs, const float FloorDistance);
	static bool DetectIsInView(const struct FVector2D& UV, const struct FVector2D& OuterRadiusUV, const bool bIsCircular);
	static class UMapViewComponent* FindMapView(class UObject* WorldContextObject, const EMapViewSearchOption MapViewSearchOption);
	static class AMapBackground* GetFirstMapBackground(const class UObject* WorldContextObject);
	static class UMapTrackerComponent* GetMapTracker(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapFunctionLibrary">();
	}
	static class UMapFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapFunctionLibrary>();
	}
};
static_assert(alignof(UMapFunctionLibrary) == 0x000008, "Wrong alignment on UMapFunctionLibrary");
static_assert(sizeof(UMapFunctionLibrary) == 0x000028, "Wrong size on UMapFunctionLibrary");

// Class MinimapPlugin.MapIconComponent
// 0x0260 (0x07C0 - 0x0560)
class UMapIconComponent final : public UBillboardComponent
{
public:
	FMulticastInlineDelegateProperty_             OnIconAppearanceChanged;                           // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconMaterialChanged;                             // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconMaterialInstancesChanged;                    // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconEnteredView;                                 // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconLeftView;                                    // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconDestroyed;                                   // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconHoverStart;                                  // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconHoverEnd;                                    // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconClicked;                                     // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   IconCategory;                                      // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             IconTexture;                                       // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     IconMaterial_UMG;                                  // 0x0600(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     IconMaterial_Canvas;                               // 0x0608(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconVisible;                                      // 0x0610(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconRotates;                                      // 0x0611(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIconSizeUnit                                 IconSizeUnit;                                      // 0x0612(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2519[0x1];                                     // 0x0613(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconSize;                                          // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconDrawColor;                                     // 0x0618(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IconZOrder;                                        // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObjectiveArrowEnabled;                            // 0x062C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251A[0x3];                                     // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ObjectiveArrowTexture;                             // 0x0630(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ObjectiveArrowMaterial_UMG;                        // 0x0638(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ObjectiveArrowMaterial_Canvas;                     // 0x0640(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObjectiveArrowRotates;                            // 0x0648(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251B[0x3];                                     // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObjectiveArrowSize;                                // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconInteractable;                                 // 0x0650(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251C[0x3];                                     // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IconTooltipText;                                   // 0x0654(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIconBackgroundInteraction                    IconBackgroundInteraction;                         // 0x065C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIconFogInteraction                           IconFogInteraction;                                // 0x065D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251D[0x2];                                     // 0x065E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconFogRevealThreshold;                            // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideOwnerInsideFog;                               // 0x0664(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251E[0x3];                                     // 0x0665(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMapViewComponent*, bool>          IsRenderedPerView;                                 // 0x0668(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     InitialIconMaterial_UMG;                           // 0x06B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     InitialIconMaterial_Canvas;                        // 0x06C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UUserWidget*, class UMaterialInstanceDynamic*> IconMaterialInstances_UMG;                         // 0x06C8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> IconMaterialInstances_Canvas;                      // 0x0718(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMapRendererComponent*, class UMaterialInstanceDynamic*> ObjectiveArrowMaterialInstances_Canvas;            // 0x0768(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251F[0x8];                                     // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetIconMaterialInstancesForCanvas(TArray<class UMaterialInstanceDynamic*>* MaterialInstances);
	void GetIconMaterialInstancesForUMG(TArray<class UMaterialInstanceDynamic*>* MaterialInstances);
	bool MarkRenderedInView(class UMapViewComponent* View, const bool bNewIsRendered);
	void ReceiveClicked(const bool bIsLeftMouseButton);
	void ReceiveHoverEnd();
	void ReceiveHoverStart();
	void RegisterMaterialInstanceFromUMG(class UUserWidget* IconWidget, class UMaterialInstanceDynamic* MatInst);
	void ResetIconMaterialForCanvas();
	void ResetIconMaterialForUMG();
	void SetIconBackgroundInteraction(const EIconBackgroundInteraction NewBackgroundInteraction);
	void SetIconDrawColor(const struct FLinearColor& NewDrawColor);
	void SetIconFogInteraction(const EIconFogInteraction NewFogInteraction);
	void SetIconFogRevealThreshold(const float NewFogRevealThreshold);
	void SetIconInteractable(const bool bNewInteractable);
	void SetIconMaterialForCanvas(class UMaterialInterface* NewMaterial);
	void SetIconMaterialForUMG(class UMaterialInterface* NewMaterial);
	void SetIconRotates(const bool bNewRotates);
	void SetIconSize(const float NewIconSize, const EIconSizeUnit NewIconSizeUnit);
	void SetIconTexture(class UTexture2D* NewIcon);
	void SetIconTooltipText(class FName NewIconName);
	void SetIconVisible(const bool bNewVisible);
	void SetIconZOrder(const int32 NewZOrder);
	void SetObjectiveArrowEnabled(const bool bNewObjectiveArrowEnabled);
	void SetObjectiveArrowRotates(const bool bNewRotates);
	void SetObjectiveArrowSize(const float NewObjectiveArrowSize);
	void SetObjectiveArrowTexture(class UTexture2D* NewTexture);

	bool DoesIconRotate() const;
	bool DoesObjectiveArrowRotate() const;
	EIconBackgroundInteraction GetIconBackgroundInteraction() const;
	struct FLinearColor GetIconDrawColor() const;
	EIconFogInteraction GetIconFogInteraction() const;
	float GetIconFogRevealThreshold() const;
	class UMaterialInterface* GetIconMaterialForCanvas() const;
	class UMaterialInterface* GetIconMaterialForUMG() const;
	float GetIconSize() const;
	EIconSizeUnit GetIconSizeUnit() const;
	class UTexture2D* GetIconTexture() const;
	class FName GetIconTooltipText() const;
	int32 GetIconZOrder() const;
	class UMaterialInterface* GetObjectiveArrowMaterialForCanvas() const;
	class UMaterialInterface* GetObjectiveArrowMaterialForUMG() const;
	float GetObjectiveArrowSize() const;
	class UTexture2D* GetObjectiveArrowTexture() const;
	bool IsIconInteractable() const;
	bool IsIconVisible() const;
	bool IsObjectiveArrowEnabled() const;
	bool IsRenderedInView(class UMapViewComponent* View) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconComponent">();
	}
	static class UMapIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapIconComponent>();
	}
};
static_assert(alignof(UMapIconComponent) == 0x000010, "Wrong alignment on UMapIconComponent");
static_assert(sizeof(UMapIconComponent) == 0x0007C0, "Wrong size on UMapIconComponent");
static_assert(offsetof(UMapIconComponent, OnIconAppearanceChanged) == 0x000560, "Member 'UMapIconComponent::OnIconAppearanceChanged' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconMaterialChanged) == 0x000570, "Member 'UMapIconComponent::OnIconMaterialChanged' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconMaterialInstancesChanged) == 0x000580, "Member 'UMapIconComponent::OnIconMaterialInstancesChanged' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconEnteredView) == 0x000590, "Member 'UMapIconComponent::OnIconEnteredView' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconLeftView) == 0x0005A0, "Member 'UMapIconComponent::OnIconLeftView' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconDestroyed) == 0x0005B0, "Member 'UMapIconComponent::OnIconDestroyed' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconHoverStart) == 0x0005C0, "Member 'UMapIconComponent::OnIconHoverStart' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconHoverEnd) == 0x0005D0, "Member 'UMapIconComponent::OnIconHoverEnd' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, OnIconClicked) == 0x0005E0, "Member 'UMapIconComponent::OnIconClicked' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconCategory) == 0x0005F0, "Member 'UMapIconComponent::IconCategory' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconTexture) == 0x0005F8, "Member 'UMapIconComponent::IconTexture' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterial_UMG) == 0x000600, "Member 'UMapIconComponent::IconMaterial_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterial_Canvas) == 0x000608, "Member 'UMapIconComponent::IconMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIconVisible) == 0x000610, "Member 'UMapIconComponent::bIconVisible' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIconRotates) == 0x000611, "Member 'UMapIconComponent::bIconRotates' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconSizeUnit) == 0x000612, "Member 'UMapIconComponent::IconSizeUnit' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconSize) == 0x000614, "Member 'UMapIconComponent::IconSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconDrawColor) == 0x000618, "Member 'UMapIconComponent::IconDrawColor' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconZOrder) == 0x000628, "Member 'UMapIconComponent::IconZOrder' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bObjectiveArrowEnabled) == 0x00062C, "Member 'UMapIconComponent::bObjectiveArrowEnabled' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowTexture) == 0x000630, "Member 'UMapIconComponent::ObjectiveArrowTexture' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowMaterial_UMG) == 0x000638, "Member 'UMapIconComponent::ObjectiveArrowMaterial_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowMaterial_Canvas) == 0x000640, "Member 'UMapIconComponent::ObjectiveArrowMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bObjectiveArrowRotates) == 0x000648, "Member 'UMapIconComponent::bObjectiveArrowRotates' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowSize) == 0x00064C, "Member 'UMapIconComponent::ObjectiveArrowSize' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bIconInteractable) == 0x000650, "Member 'UMapIconComponent::bIconInteractable' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconTooltipText) == 0x000654, "Member 'UMapIconComponent::IconTooltipText' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconBackgroundInteraction) == 0x00065C, "Member 'UMapIconComponent::IconBackgroundInteraction' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconFogInteraction) == 0x00065D, "Member 'UMapIconComponent::IconFogInteraction' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconFogRevealThreshold) == 0x000660, "Member 'UMapIconComponent::IconFogRevealThreshold' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, bHideOwnerInsideFog) == 0x000664, "Member 'UMapIconComponent::bHideOwnerInsideFog' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IsRenderedPerView) == 0x000668, "Member 'UMapIconComponent::IsRenderedPerView' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, InitialIconMaterial_UMG) == 0x0006B8, "Member 'UMapIconComponent::InitialIconMaterial_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, InitialIconMaterial_Canvas) == 0x0006C0, "Member 'UMapIconComponent::InitialIconMaterial_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterialInstances_UMG) == 0x0006C8, "Member 'UMapIconComponent::IconMaterialInstances_UMG' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, IconMaterialInstances_Canvas) == 0x000718, "Member 'UMapIconComponent::IconMaterialInstances_Canvas' has a wrong offset!");
static_assert(offsetof(UMapIconComponent, ObjectiveArrowMaterialInstances_Canvas) == 0x000768, "Member 'UMapIconComponent::ObjectiveArrowMaterialInstances_Canvas' has a wrong offset!");

// Class MinimapPlugin.MapRendererComponent
// 0x00E8 (0x0188 - 0x00A0)
class UMapRendererComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMapClicked;                                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMapViewSearchOption                          AutoLocateMapView;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCircular;                                       // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRendered;                                       // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawFrustum;                                      // 0x00B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrustumFloorDistance;                              // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundFillColor;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2523[0x2];                                     // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Margin;                                            // 0x00CC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2524[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FillMaterial;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               FillMaterialInstance;                              // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapTrackerComponent*                   MapTracker;                                        // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapViewComponent*                      MapView;                                           // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UMapIconComponent*>                HoveringIcons;                                     // 0x0110(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMapIconComponent*>              BufferedHoverStartEvents;                          // 0x0160(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMapIconComponent*>              BufferedHoverEndEvents;                            // 0x0170(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvas*                                LastCanvas;                                        // 0x0180(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetAutoLocateMapView(const EMapViewSearchOption InAutoLocateMapView);
	void SetBackgroundFillColor(const struct FLinearColor& NewBackgroundFillColor);
	void SetDrawFrustum(const bool bNewDrawFrustum);
	void SetFrustumFloorDistance(const float NewFrustumFloorDistance);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetIsCircular(const bool bNewIsCircular);
	void SetIsRendered(const bool bNewIsRendered);
	void SetMapView(class UMapViewComponent* InMapView);
	void SetMargin(const int32 Left, const int32 Top, const int32 Right, const int32 Bottom);
	void SetSize(const int32 Width, const int32 Height);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

	struct FLinearColor GetBackgroundFillColor() const;
	bool GetDrawFrustum() const;
	float GetFrustumFloorDistance() const;
	bool IsCircular() const;
	bool IsRendered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRendererComponent">();
	}
	static class UMapRendererComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRendererComponent>();
	}
};
static_assert(alignof(UMapRendererComponent) == 0x000008, "Wrong alignment on UMapRendererComponent");
static_assert(sizeof(UMapRendererComponent) == 0x000188, "Wrong size on UMapRendererComponent");
static_assert(offsetof(UMapRendererComponent, OnMapClicked) == 0x0000A0, "Member 'UMapRendererComponent::OnMapClicked' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, AutoLocateMapView) == 0x0000B0, "Member 'UMapRendererComponent::AutoLocateMapView' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, bIsCircular) == 0x0000B1, "Member 'UMapRendererComponent::bIsCircular' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, bIsRendered) == 0x0000B2, "Member 'UMapRendererComponent::bIsRendered' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, bDrawFrustum) == 0x0000B3, "Member 'UMapRendererComponent::bDrawFrustum' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, FrustumFloorDistance) == 0x0000B4, "Member 'UMapRendererComponent::FrustumFloorDistance' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, BackgroundFillColor) == 0x0000B8, "Member 'UMapRendererComponent::BackgroundFillColor' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, HorizontalAlignment) == 0x0000C8, "Member 'UMapRendererComponent::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, VerticalAlignment) == 0x0000C9, "Member 'UMapRendererComponent::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, Margin) == 0x0000CC, "Member 'UMapRendererComponent::Margin' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, Size) == 0x0000E0, "Member 'UMapRendererComponent::Size' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, FillMaterial) == 0x0000F0, "Member 'UMapRendererComponent::FillMaterial' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, FillMaterialInstance) == 0x0000F8, "Member 'UMapRendererComponent::FillMaterialInstance' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, MapTracker) == 0x000100, "Member 'UMapRendererComponent::MapTracker' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, MapView) == 0x000108, "Member 'UMapRendererComponent::MapView' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, HoveringIcons) == 0x000110, "Member 'UMapRendererComponent::HoveringIcons' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, BufferedHoverStartEvents) == 0x000160, "Member 'UMapRendererComponent::BufferedHoverStartEvents' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, BufferedHoverEndEvents) == 0x000170, "Member 'UMapRendererComponent::BufferedHoverEndEvents' has a wrong offset!");
static_assert(offsetof(UMapRendererComponent, LastCanvas) == 0x000180, "Member 'UMapRendererComponent::LastCanvas' has a wrong offset!");

// Class MinimapPlugin.MapTrackerComponent
// 0x00C0 (0x0160 - 0x00A0)
class UMapTrackerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMapIconRegistered;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapIconUnregistered;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundRegistered;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapBackgroundUnregistered;                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapFogRegistered;                                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapFogUnregistered;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapRevealerRegistered;                           // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapRevealerUnregistered;                         // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMapIconComponent*>              MapIcons;                                          // 0x0120(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AMapBackground*>                 MapBackgrounds;                                    // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMapFog*>                        MapFogs;                                           // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMapRevealerComponent*>          MapRevealers;                                      // 0x0150(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	float GetFogRevealedFactor(const struct FVector& WorldLocation, const bool bRequireCurrentlyRevealing, bool* bIsInsideFogVolume) const;
	const TArray<class AMapBackground*> GetMapBackgrounds() const;
	const TArray<class AMapFog*> GetMapFogs() const;
	const TArray<class UMapIconComponent*> GetMapIcons() const;
	const TArray<class UMapRevealerComponent*> GetMapRevealers() const;
	bool HasMapFog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTrackerComponent">();
	}
	static class UMapTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapTrackerComponent>();
	}
};
static_assert(alignof(UMapTrackerComponent) == 0x000008, "Wrong alignment on UMapTrackerComponent");
static_assert(sizeof(UMapTrackerComponent) == 0x000160, "Wrong size on UMapTrackerComponent");
static_assert(offsetof(UMapTrackerComponent, OnMapIconRegistered) == 0x0000A0, "Member 'UMapTrackerComponent::OnMapIconRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapIconUnregistered) == 0x0000B0, "Member 'UMapTrackerComponent::OnMapIconUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapBackgroundRegistered) == 0x0000C0, "Member 'UMapTrackerComponent::OnMapBackgroundRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapBackgroundUnregistered) == 0x0000D0, "Member 'UMapTrackerComponent::OnMapBackgroundUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapFogRegistered) == 0x0000E0, "Member 'UMapTrackerComponent::OnMapFogRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapFogUnregistered) == 0x0000F0, "Member 'UMapTrackerComponent::OnMapFogUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapRevealerRegistered) == 0x000100, "Member 'UMapTrackerComponent::OnMapRevealerRegistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, OnMapRevealerUnregistered) == 0x000110, "Member 'UMapTrackerComponent::OnMapRevealerUnregistered' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapIcons) == 0x000120, "Member 'UMapTrackerComponent::MapIcons' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapBackgrounds) == 0x000130, "Member 'UMapTrackerComponent::MapBackgrounds' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapFogs) == 0x000140, "Member 'UMapTrackerComponent::MapFogs' has a wrong offset!");
static_assert(offsetof(UMapTrackerComponent, MapRevealers) == 0x000150, "Member 'UMapTrackerComponent::MapRevealers' has a wrong offset!");

// Class MinimapPlugin.MapViewComponent
// 0x0290 (0x0810 - 0x0580)
class UMapViewComponent final : public UBoxComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVisibleCategoriesChanged;                        // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewSizeChanged;                                 // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewDestroyed;                                   // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMapViewRotationMode                          RotationMode;                                      // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2526[0x7];                                     // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedRotation;                                     // 0x05B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InheritedYawOffset;                                // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportZooming;                                   // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2527[0x3];                                     // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HeightProxy;                                       // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackgoundLevelCacheLifetime;                       // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2528[0x144];                                   // 0x05DC(0x0144)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AMapBackground*>                   MapBackgrounds;                                    // 0x0720(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AMapBackground*, int32>            PositionOnMultiLevelBackgrounds;                   // 0x0770(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2529[0x50];                                    // 0x07C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeprojectViewToWorld(const float U, const float V, struct FVector* WorldPos);
	int32 GetActiveBackgroundLevel(const class AMapBackground* MapBackground);
	int32 GetActiveBackgroundPriority(bool* IsInsideAnyBackground);
	bool GetViewCoordinates(const struct FVector& WorldPos, bool bForceRectangular, float* U, float* V);
	void GetViewYaw(const float WorldYaw, float* Yaw);
	TArray<struct FVector> GetWorldCorners();
	bool IsSameBackgroundLevel(const class UMapIconComponent* MapIcon);
	void RegisterMultiLevelMapBackground(class AMapBackground* MapBackground);
	void SetIconCategoryVisible(class FName IconCategory, const bool bNewVisible);
	void SetViewExtent(const float NewViewExtentX, const float NewViewExtentY);
	void SetZoomScale(const float NewZoomScale);
	void UnregisterMultiLevelMapBackground(class AMapBackground* MapBackground);

	float GetViewAspectRatio() const;
	void GetViewExtent(float* ViewExtentX, float* ViewExtentY) const;
	float GetZoomScale() const;
	bool IsIconCategoryVisible(class FName IconCategory) const;
	bool ViewContains(const struct FVector& WorldPos, const float WorldRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapViewComponent">();
	}
	static class UMapViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapViewComponent>();
	}
};
static_assert(alignof(UMapViewComponent) == 0x000010, "Wrong alignment on UMapViewComponent");
static_assert(sizeof(UMapViewComponent) == 0x000810, "Wrong size on UMapViewComponent");
static_assert(offsetof(UMapViewComponent, OnVisibleCategoriesChanged) == 0x000578, "Member 'UMapViewComponent::OnVisibleCategoriesChanged' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, OnViewSizeChanged) == 0x000588, "Member 'UMapViewComponent::OnViewSizeChanged' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, OnViewDestroyed) == 0x000598, "Member 'UMapViewComponent::OnViewDestroyed' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, RotationMode) == 0x0005A8, "Member 'UMapViewComponent::RotationMode' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, FixedRotation) == 0x0005B0, "Member 'UMapViewComponent::FixedRotation' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, InheritedYawOffset) == 0x0005C8, "Member 'UMapViewComponent::InheritedYawOffset' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, bSupportZooming) == 0x0005CC, "Member 'UMapViewComponent::bSupportZooming' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, HeightProxy) == 0x0005D0, "Member 'UMapViewComponent::HeightProxy' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, BackgoundLevelCacheLifetime) == 0x0005D8, "Member 'UMapViewComponent::BackgoundLevelCacheLifetime' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, MapBackgrounds) == 0x000720, "Member 'UMapViewComponent::MapBackgrounds' has a wrong offset!");
static_assert(offsetof(UMapViewComponent, PositionOnMultiLevelBackgrounds) == 0x000770, "Member 'UMapViewComponent::PositionOnMultiLevelBackgrounds' has a wrong offset!");

}

