#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VaultIt

#include "Basic.hpp"

#include "VaultIt_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class VaultIt.VIAbilitySystemComponent
// 0x0020 (0x13C0 - 0x13A0)
class UVIAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	TArray<struct FVIGameplayAbilityLocalAnimMontageForMesh> LocalAnimMontageInfoForMeshes;                     // 0x13A0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVIGameplayAbilityRepAnimMontageForMesh> RepAnimMontageInfoForMeshes;                       // 0x13B0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_ReplicatedAnimMontageForMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIAbilitySystemComponent">();
	}
	static class UVIAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIAbilitySystemComponent>();
	}
};
static_assert(alignof(UVIAbilitySystemComponent) == 0x000008, "Wrong alignment on UVIAbilitySystemComponent");
static_assert(sizeof(UVIAbilitySystemComponent) == 0x0013C0, "Wrong size on UVIAbilitySystemComponent");
static_assert(offsetof(UVIAbilitySystemComponent, LocalAnimMontageInfoForMeshes) == 0x0013A0, "Member 'UVIAbilitySystemComponent::LocalAnimMontageInfoForMeshes' has a wrong offset!");
static_assert(offsetof(UVIAbilitySystemComponent, RepAnimMontageInfoForMeshes) == 0x0013B0, "Member 'UVIAbilitySystemComponent::RepAnimMontageInfoForMeshes' has a wrong offset!");

// Class VaultIt.VIGameplayAbility
// 0x0010 (0x03C8 - 0x03B8)
class UVIGameplayAbility : public UGameplayAbility
{
public:
	TArray<struct FVIAbilityMeshMontage>          CurrentAbilityMeshMontages;                        // 0x03B8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	class FString GetCurrentPredictionKeyStatus() const;
	bool IsPredictionKeyValidForMorePrediction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIGameplayAbility">();
	}
	static class UVIGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIGameplayAbility>();
	}
};
static_assert(alignof(UVIGameplayAbility) == 0x000008, "Wrong alignment on UVIGameplayAbility");
static_assert(sizeof(UVIGameplayAbility) == 0x0003C8, "Wrong size on UVIGameplayAbility");
static_assert(offsetof(UVIGameplayAbility, CurrentAbilityMeshMontages) == 0x0003B8, "Member 'UVIGameplayAbility::CurrentAbilityMeshMontages' has a wrong offset!");

// Class VaultIt.VIAnimationInterface
// 0x0000 (0x0028 - 0x0028)
class IVIAnimationInterface final : public IInterface
{
public:
	void SetBoneFBIK(const class FName& BoneName, const struct FVector& BoneLocation, bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIAnimationInterface">();
	}
	static class IVIAnimationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVIAnimationInterface>();
	}
};
static_assert(alignof(IVIAnimationInterface) == 0x000008, "Wrong alignment on IVIAnimationInterface");
static_assert(sizeof(IVIAnimationInterface) == 0x000028, "Wrong size on IVIAnimationInterface");

// Class VaultIt.GameplayAbility_Vault
// 0x0000 (0x03C8 - 0x03C8)
class UGameplayAbility_Vault final : public UVIGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_Vault">();
	}
	static class UGameplayAbility_Vault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_Vault>();
	}
};
static_assert(alignof(UGameplayAbility_Vault) == 0x000008, "Wrong alignment on UGameplayAbility_Vault");
static_assert(sizeof(UGameplayAbility_Vault) == 0x0003C8, "Wrong size on UGameplayAbility_Vault");

// Class VaultIt.VIAnimInstance
// 0x0070 (0x03C0 - 0x0350)
class UVIAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_1AE5[0x8];                                     // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RHandName;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LHandName;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVIBoneFBIKData>                FBIK;                                              // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRHand;                                            // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLHand;                                            // 0x0371(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBothHand;                                         // 0x0372(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AE6[0x5];                                     // 0x0373(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RHandLoc;                                          // 0x0378(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LHandLoc;                                          // 0x0390(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVaulting;                                       // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AE7[0x7];                                     // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AVICharacterBase*                       Character;                                         // 0x03B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x03B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AE8[0x2];                                     // 0x03BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnStartVault();
	void K2_OnStopVault();
	void SetBoneFBIK(const class FName& BoneName, const struct FVector& BoneLocation, bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIAnimInstance">();
	}
	static class UVIAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIAnimInstance>();
	}
};
static_assert(alignof(UVIAnimInstance) == 0x000010, "Wrong alignment on UVIAnimInstance");
static_assert(sizeof(UVIAnimInstance) == 0x0003C0, "Wrong size on UVIAnimInstance");
static_assert(offsetof(UVIAnimInstance, RHandName) == 0x000350, "Member 'UVIAnimInstance::RHandName' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, LHandName) == 0x000358, "Member 'UVIAnimInstance::LHandName' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, FBIK) == 0x000360, "Member 'UVIAnimInstance::FBIK' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, bRHand) == 0x000370, "Member 'UVIAnimInstance::bRHand' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, bLHand) == 0x000371, "Member 'UVIAnimInstance::bLHand' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, bBothHand) == 0x000372, "Member 'UVIAnimInstance::bBothHand' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, RHandLoc) == 0x000378, "Member 'UVIAnimInstance::RHandLoc' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, LHandLoc) == 0x000390, "Member 'UVIAnimInstance::LHandLoc' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, bIsVaulting) == 0x0003A8, "Member 'UVIAnimInstance::bIsVaulting' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, Character) == 0x0003B0, "Member 'UVIAnimInstance::Character' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, bIsJumping) == 0x0003B8, "Member 'UVIAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, bIsFalling) == 0x0003B9, "Member 'UVIAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UVIAnimInstance, Speed) == 0x0003BC, "Member 'UVIAnimInstance::Speed' has a wrong offset!");

// Class VaultIt.VIAnimInstanceFP
// 0x0060 (0x0420 - 0x03C0)
class UVIAnimInstanceFP final : public UVIAnimInstance
{
public:
	TMap<class UAnimMontage*, class UAnimMontage*> MontageLinkMap;                                    // 0x03C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x0410(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VaultBlendOutTime;                                 // 0x0418(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AEA[0x4];                                     // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIAnimInstanceFP">();
	}
	static class UVIAnimInstanceFP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIAnimInstanceFP>();
	}
};
static_assert(alignof(UVIAnimInstanceFP) == 0x000010, "Wrong alignment on UVIAnimInstanceFP");
static_assert(sizeof(UVIAnimInstanceFP) == 0x000420, "Wrong size on UVIAnimInstanceFP");
static_assert(offsetof(UVIAnimInstanceFP, MontageLinkMap) == 0x0003C0, "Member 'UVIAnimInstanceFP::MontageLinkMap' has a wrong offset!");
static_assert(offsetof(UVIAnimInstanceFP, MontageToPlay) == 0x000410, "Member 'UVIAnimInstanceFP::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UVIAnimInstanceFP, VaultBlendOutTime) == 0x000418, "Member 'UVIAnimInstanceFP::VaultBlendOutTime' has a wrong offset!");

// Class VaultIt.PlayMontageForMeshAndWait
// 0x0098 (0x0118 - 0x0080)
class UPlayMontageForMeshAndWait final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReplicateMontage;                                 // 0x00E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AEB[0x2];                                     // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideBlendOutTimeForCancelAbility;              // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverrideBlendOutTimeForStopWhenEndAbility;         // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AEC[0x2C];                                    // 0x00EC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlayMontageForMeshAndWait* PlayMontageForMeshAndWait(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class USkeletalMeshComponent* Param_Mesh, class UAnimMontage* Param_MontageToPlay, float Param_Rate, class FName Param_StartSection, bool Param_bStopWhenAbilityEnds, float Param_AnimRootMotionTranslationScale, bool Param_bReplicateMontage, float Param_OverrideBlendOutTimeForCancelAbility, float Param_OverrideBlendOutTimeForStopWhenEndAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayMontageForMeshAndWait">();
	}
	static class UPlayMontageForMeshAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayMontageForMeshAndWait>();
	}
};
static_assert(alignof(UPlayMontageForMeshAndWait) == 0x000008, "Wrong alignment on UPlayMontageForMeshAndWait");
static_assert(sizeof(UPlayMontageForMeshAndWait) == 0x000118, "Wrong size on UPlayMontageForMeshAndWait");
static_assert(offsetof(UPlayMontageForMeshAndWait, OnCompleted) == 0x000080, "Member 'UPlayMontageForMeshAndWait::OnCompleted' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, OnBlendOut) == 0x000090, "Member 'UPlayMontageForMeshAndWait::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, OnInterrupted) == 0x0000A0, "Member 'UPlayMontageForMeshAndWait::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, OnCancelled) == 0x0000B0, "Member 'UPlayMontageForMeshAndWait::OnCancelled' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, Mesh) == 0x0000C0, "Member 'UPlayMontageForMeshAndWait::Mesh' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, MontageToPlay) == 0x0000C8, "Member 'UPlayMontageForMeshAndWait::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, Rate) == 0x0000D0, "Member 'UPlayMontageForMeshAndWait::Rate' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, StartSection) == 0x0000D4, "Member 'UPlayMontageForMeshAndWait::StartSection' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, AnimRootMotionTranslationScale) == 0x0000DC, "Member 'UPlayMontageForMeshAndWait::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, bStopWhenAbilityEnds) == 0x0000E0, "Member 'UPlayMontageForMeshAndWait::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, bReplicateMontage) == 0x0000E1, "Member 'UPlayMontageForMeshAndWait::bReplicateMontage' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, OverrideBlendOutTimeForCancelAbility) == 0x0000E4, "Member 'UPlayMontageForMeshAndWait::OverrideBlendOutTimeForCancelAbility' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWait, OverrideBlendOutTimeForStopWhenEndAbility) == 0x0000E8, "Member 'UPlayMontageForMeshAndWait::OverrideBlendOutTimeForStopWhenEndAbility' has a wrong offset!");

// Class VaultIt.VIAnimNotifyState_FBIK
// 0x0028 (0x0058 - 0x0030)
class UVIAnimNotifyState_FBIK final : public UAnimNotifyState
{
public:
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneOffset;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableIfHitFails;                                // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIFBIKTraceType                              TraceType;                                         // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIFBIKUpdateType                             UpdateType;                                        // 0x0046(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TickSkipAmount;                                    // 0x0047(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIFBIKUpdateRole                             ApplyToRoles;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTraceDuringPIE;                              // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AEF[0xE];                                     // 0x004A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIAnimNotifyState_FBIK">();
	}
	static class UVIAnimNotifyState_FBIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIAnimNotifyState_FBIK>();
	}
};
static_assert(alignof(UVIAnimNotifyState_FBIK) == 0x000008, "Wrong alignment on UVIAnimNotifyState_FBIK");
static_assert(sizeof(UVIAnimNotifyState_FBIK) == 0x000058, "Wrong size on UVIAnimNotifyState_FBIK");
static_assert(offsetof(UVIAnimNotifyState_FBIK, BoneName) == 0x000030, "Member 'UVIAnimNotifyState_FBIK::BoneName' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, TraceLength) == 0x000038, "Member 'UVIAnimNotifyState_FBIK::TraceLength' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, TraceRadius) == 0x00003C, "Member 'UVIAnimNotifyState_FBIK::TraceRadius' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, BoneOffset) == 0x000040, "Member 'UVIAnimNotifyState_FBIK::BoneOffset' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, bDisableIfHitFails) == 0x000044, "Member 'UVIAnimNotifyState_FBIK::bDisableIfHitFails' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, TraceType) == 0x000045, "Member 'UVIAnimNotifyState_FBIK::TraceType' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, UpdateType) == 0x000046, "Member 'UVIAnimNotifyState_FBIK::UpdateType' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, TickSkipAmount) == 0x000047, "Member 'UVIAnimNotifyState_FBIK::TickSkipAmount' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, ApplyToRoles) == 0x000048, "Member 'UVIAnimNotifyState_FBIK::ApplyToRoles' has a wrong offset!");
static_assert(offsetof(UVIAnimNotifyState_FBIK, bDebugTraceDuringPIE) == 0x000049, "Member 'UVIAnimNotifyState_FBIK::bDebugTraceDuringPIE' has a wrong offset!");

// Class VaultIt.VIAssetManager
// 0x0000 (0x04E8 - 0x04E8)
class UVIAssetManager final : public UAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIAssetManager">();
	}
	static class UVIAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIAssetManager>();
	}
};
static_assert(alignof(UVIAssetManager) == 0x000008, "Wrong alignment on UVIAssetManager");
static_assert(sizeof(UVIAssetManager) == 0x0004E8, "Wrong size on UVIAssetManager");

// Class VaultIt.VIBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVIBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorIsAscending(class AActor* InActor, bool bWorldUpIsZ);
	static float ComputeAnimationPlayRateFromDuration(class UAnimSequenceBase* Animation, float Duration);
	static float GetMaxHeightFromGround(class ACharacter* Character);
	static float GetMaxHeightFromGroundForPawn(class APawn* Pawn, const float Gravity, const float JumpZVelocity);
	static float GetMaxJumpHeight(const float Gravity, const float JumpZVelocity);
	static float GetMaxJumpHeightForCharacter(class ACharacter* Character);
	static float GetMaxVaultHeight(class APawn* Pawn);
	static struct FVIVaultInfo GetVaultInfoFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	static void InterpolateFBIK(float DeltaTime, TArray<struct FVIBoneFBIKData>& Bones);
	static bool IsRunningOnServer(class AActor* Actor);
	static struct FVIBoneFBIKData K2_GetBoneForFBIK(class FName BoneName, const TArray<struct FVIBoneFBIKData>& Bones);
	static void ToggleBoneFBIK(const class FName& BoneName, const struct FVector& NewLocation, bool bEnable, TArray<struct FVIBoneFBIKData>& Bones);
	static bool VaultAnimSetIsValid(const struct FVIAnimSet& AnimSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIBlueprintFunctionLibrary">();
	}
	static class UVIBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UVIBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UVIBlueprintFunctionLibrary");
static_assert(sizeof(UVIBlueprintFunctionLibrary) == 0x000028, "Wrong size on UVIBlueprintFunctionLibrary");

// Class VaultIt.VICharacterBase
// 0x0050 (0x0670 - 0x0620)
class AVICharacterBase : public ACharacter
{
public:
	uint8                                         Pad_1AF9[0x8];                                     // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVIMotionWarpingComponent*              MotionWarping;                                     // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVIPawnVaultComponent*                  VaultComponent;                                    // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepIsVaulting;                                    // 0x0630(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasVaulting;                                      // 0x0631(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AFA[0x6];                                     // 0x0632(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVIRepMotionMatch                      RepMotionMatch;                                    // 0x0638(0x0030)(BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AFB[0x8];                                     // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MotionMatch();
	void OnStopVaultAbility();
	void StopVaultAbility();

	bool IsVaulting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VICharacterBase">();
	}
	static class AVICharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVICharacterBase>();
	}
};
static_assert(alignof(AVICharacterBase) == 0x000010, "Wrong alignment on AVICharacterBase");
static_assert(sizeof(AVICharacterBase) == 0x000670, "Wrong size on AVICharacterBase");
static_assert(offsetof(AVICharacterBase, MotionWarping) == 0x000620, "Member 'AVICharacterBase::MotionWarping' has a wrong offset!");
static_assert(offsetof(AVICharacterBase, VaultComponent) == 0x000628, "Member 'AVICharacterBase::VaultComponent' has a wrong offset!");
static_assert(offsetof(AVICharacterBase, bRepIsVaulting) == 0x000630, "Member 'AVICharacterBase::bRepIsVaulting' has a wrong offset!");
static_assert(offsetof(AVICharacterBase, bWasVaulting) == 0x000631, "Member 'AVICharacterBase::bWasVaulting' has a wrong offset!");
static_assert(offsetof(AVICharacterBase, RepMotionMatch) == 0x000638, "Member 'AVICharacterBase::RepMotionMatch' has a wrong offset!");

// Class VaultIt.VICharacterAbilityBase
// 0x0010 (0x0680 - 0x0670)
class AVICharacterAbilityBase : public AVICharacterBase
{
public:
	class UVIAbilitySystemComponent*              AbilitySystem;                                     // 0x0670(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIGameplayEffectReplicationMode              AbilitySystemReplicationMode;                      // 0x0678(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AFC[0x7];                                     // 0x0679(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VICharacterAbilityBase">();
	}
	static class AVICharacterAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVICharacterAbilityBase>();
	}
};
static_assert(alignof(AVICharacterAbilityBase) == 0x000010, "Wrong alignment on AVICharacterAbilityBase");
static_assert(sizeof(AVICharacterAbilityBase) == 0x000680, "Wrong size on AVICharacterAbilityBase");
static_assert(offsetof(AVICharacterAbilityBase, AbilitySystem) == 0x000670, "Member 'AVICharacterAbilityBase::AbilitySystem' has a wrong offset!");
static_assert(offsetof(AVICharacterAbilityBase, AbilitySystemReplicationMode) == 0x000678, "Member 'AVICharacterAbilityBase::AbilitySystemReplicationMode' has a wrong offset!");

// Class VaultIt.VICharacter
// 0x0090 (0x0710 - 0x0680)
class AVICharacter final : public AVICharacterAbilityBase
{
public:
	struct FVIAnimSet                             VaultAnimSet;                                      // 0x0680(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVITraceSettings                       VaultTraceSettings;                                // 0x06D0(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFD[0x8];                                     // 0x0708(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VICharacter">();
	}
	static class AVICharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVICharacter>();
	}
};
static_assert(alignof(AVICharacter) == 0x000010, "Wrong alignment on AVICharacter");
static_assert(sizeof(AVICharacter) == 0x000710, "Wrong size on AVICharacter");
static_assert(offsetof(AVICharacter, VaultAnimSet) == 0x000680, "Member 'AVICharacter::VaultAnimSet' has a wrong offset!");
static_assert(offsetof(AVICharacter, VaultTraceSettings) == 0x0006D0, "Member 'AVICharacter::VaultTraceSettings' has a wrong offset!");

// Class VaultIt.VIPawnInterface
// 0x0000 (0x0028 - 0x0028)
class IVIPawnInterface final : public IInterface
{
public:
	void OnLocalPlayerVault(const struct FVector& Location, const struct FVector& Direction);
	void ReplicateMotionMatch(const struct FVIRepMotionMatch& MotionMatch);
	void StartVaultAbility();

	bool CanAutoVaultInCustomMovementMode() const;
	bool CanVault() const;
	class USkeletalMeshComponent* GetMeshForVaultMontage() const;
	class UVIMotionWarpingComponent* GetMotionWarpingComponent() const;
	class UVIPawnVaultComponent* GetPawnVaultComponent() const;
	struct FVIAnimSet GetVaultAnimSet() const;
	struct FVector GetVaultDirection() const;
	void GetVaultLocationAndDirection(struct FVector* OutLocation, struct FVector* OutDirection) const;
	struct FVITraceSettings GetVaultTraceSettings() const;
	bool IsWalkable(const struct FHitResult& HitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPawnInterface">();
	}
	static class IVIPawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVIPawnInterface>();
	}
};
static_assert(alignof(IVIPawnInterface) == 0x000008, "Wrong alignment on IVIPawnInterface");
static_assert(sizeof(IVIPawnInterface) == 0x000028, "Wrong size on IVIPawnInterface");

// Class VaultIt.VIPawnVaultComponent
// 0x00B0 (0x0150 - 0x00A0)
class UVIPawnVaultComponent final : public UActorComponent
{
public:
	TSubclassOf<class UGameplayAbility>           VaultAbility;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VaultAbilityTag;                                   // 0x00A8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VaultStateTag;                                     // 0x00B0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VaultRemovalTag;                                   // 0x00B8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIVaultInputRelease                          AutoReleaseVaultInput;                             // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIJumpKeyPriority                            JumpKeyPriority;                                   // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFF[0x2];                                     // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalVaultHeight;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalVaultHeightFalling;                      // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanVaultFromGround;                               // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanVaultFromFalling;                              // 0x00CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanVaultFromSwimming;                             // 0x00CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanVaultFromCrouching;                            // 0x00CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AutoVaultStates;                                   // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AutoVaultCheckSkip;                                // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVIAntiCheatType                              AntiCheatType;                                     // 0x00D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B00[0x5];                                     // 0x00D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVIAntiCheatSettings                   AntiCheatSettings;                                 // 0x00D8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bVaultAbilityInitialized;                          // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressedVault;                                     // 0x00F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B01[0x2];                                     // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVICapsuleInfo                         CapsuleInfo;                                       // 0x00F4(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B02[0x44];                                    // 0x00FC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  PawnOwner;                                         // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                ASC;                                               // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CheckVaultInput(float DeltaTime, EMovementMode MovementMode);
	bool ComputeShouldAutoVault();
	bool Jump(float GravityZ, bool bCanJump, bool bIsFalling);
	void StopJumping();
	void StopVault();
	void Vault();

	bool ComputeAntiCheatResult(const struct FVIVaultInfo& VaultInfo) const;
	bool ComputeCustomAntiCheat(const struct FVIVaultInfo& ClientVaultInfo) const;
	bool ComputeDefaultAntiCheat(const struct FVIVaultInfo& ClientVaultInfo, const struct FVIVaultResult& ServerVaultResult) const;
	struct FVIVaultResult ComputeVault() const;
	struct FVIVaultInfo ComputeVaultInfoFromResult(const struct FVIVaultInfo& VaultResult) const;
	struct FVICapsuleInfo GetCapsuleInfo() const;
	bool IsCapsuleInfoValid() const;
	bool IsVaulting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPawnVaultComponent">();
	}
	static class UVIPawnVaultComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVIPawnVaultComponent>();
	}
};
static_assert(alignof(UVIPawnVaultComponent) == 0x000008, "Wrong alignment on UVIPawnVaultComponent");
static_assert(sizeof(UVIPawnVaultComponent) == 0x000150, "Wrong size on UVIPawnVaultComponent");
static_assert(offsetof(UVIPawnVaultComponent, VaultAbility) == 0x0000A0, "Member 'UVIPawnVaultComponent::VaultAbility' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, VaultAbilityTag) == 0x0000A8, "Member 'UVIPawnVaultComponent::VaultAbilityTag' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, VaultStateTag) == 0x0000B0, "Member 'UVIPawnVaultComponent::VaultStateTag' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, VaultRemovalTag) == 0x0000B8, "Member 'UVIPawnVaultComponent::VaultRemovalTag' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AutoReleaseVaultInput) == 0x0000C0, "Member 'UVIPawnVaultComponent::AutoReleaseVaultInput' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, JumpKeyPriority) == 0x0000C1, "Member 'UVIPawnVaultComponent::JumpKeyPriority' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AdditionalVaultHeight) == 0x0000C4, "Member 'UVIPawnVaultComponent::AdditionalVaultHeight' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AdditionalVaultHeightFalling) == 0x0000C8, "Member 'UVIPawnVaultComponent::AdditionalVaultHeightFalling' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, bCanVaultFromGround) == 0x0000CC, "Member 'UVIPawnVaultComponent::bCanVaultFromGround' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, bCanVaultFromFalling) == 0x0000CD, "Member 'UVIPawnVaultComponent::bCanVaultFromFalling' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, bCanVaultFromSwimming) == 0x0000CE, "Member 'UVIPawnVaultComponent::bCanVaultFromSwimming' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, bCanVaultFromCrouching) == 0x0000CF, "Member 'UVIPawnVaultComponent::bCanVaultFromCrouching' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AutoVaultStates) == 0x0000D0, "Member 'UVIPawnVaultComponent::AutoVaultStates' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AutoVaultCheckSkip) == 0x0000D1, "Member 'UVIPawnVaultComponent::AutoVaultCheckSkip' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AntiCheatType) == 0x0000D2, "Member 'UVIPawnVaultComponent::AntiCheatType' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, AntiCheatSettings) == 0x0000D8, "Member 'UVIPawnVaultComponent::AntiCheatSettings' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, bVaultAbilityInitialized) == 0x0000F0, "Member 'UVIPawnVaultComponent::bVaultAbilityInitialized' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, bPressedVault) == 0x0000F1, "Member 'UVIPawnVaultComponent::bPressedVault' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, CapsuleInfo) == 0x0000F4, "Member 'UVIPawnVaultComponent::CapsuleInfo' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, PawnOwner) == 0x000140, "Member 'UVIPawnVaultComponent::PawnOwner' has a wrong offset!");
static_assert(offsetof(UVIPawnVaultComponent, ASC) == 0x000148, "Member 'UVIPawnVaultComponent::ASC' has a wrong offset!");

}

